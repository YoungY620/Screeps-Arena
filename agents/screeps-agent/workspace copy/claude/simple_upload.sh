#!/bin/bash

# Create a simple JSON payload with the code
cat > /tmp/code.json << 'EOF'
{
  "branch": "default",
  "modules": {
    "main": "// CLAUDE PvP AGGRESSIVE STRATEGY\n// Ultimate Goal: DESTROY ALL OPPONENTS AS FAST AS POSSIBLE\n\n// Configuration\nconst DEFENSE_PRIORITY = 0.6;\nconst MAX_CREEPS = 50;\nconst TOWER_THRESHOLD = 0.7;\nconst ATTACK_THRESHOLD = 0.5;\n\n// Role definitions\nconst ROLES = {\n    HARVESTER: 'harvester',\n    BUILDER: 'builder',\n    UPGRADER: 'upgrader',\n    REPAIRER: 'repairer',\n    GUARD: 'guard',\n    ATTACKER: 'attacker',\n    RANGER: 'ranger',\n    HEALER: 'healer',\n    SCOUT: 'scout'\n};\n\n// Body part costs\nconst BODY_COSTS = {\n    move: 50,\n    work: 100,\n    carry: 50,\n    attack: 80,\n    ranged_attack: 150,\n    heal: 250,\n    tough: 10\n};\n\n// PvP Strategy: Prioritize military units and defense\nfunction getBodyParts(role, energyAvailable) {\n    const bodies = {\n        [ROLES.HARVESTER]: [\n            [WORK, WORK, CARRY, MOVE],\n            [WORK, WORK, WORK, CARRY, MOVE, MOVE],\n            [WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE]\n        ],\n        [ROLES.BUILDER]: [\n            [WORK, CARRY, MOVE],\n            [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n            [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.UPGRADER]: [\n            [WORK, CARRY, MOVE],\n            [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n            [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.REPAIRER]: [\n            [WORK, CARRY, MOVE],\n            [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n            [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.GUARD]: [\n            [TOUGH, ATTACK, MOVE],\n            [TOUGH, TOUGH, ATTACK, ATTACK, MOVE, MOVE],\n            [TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.ATTACKER]: [\n            [ATTACK, MOVE],\n            [ATTACK, ATTACK, MOVE, MOVE],\n            [ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.RANGER]: [\n            [RANGED_ATTACK, MOVE],\n            [RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE],\n            [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.HEALER]: [\n            [HEAL, MOVE],\n            [HEAL, HEAL, MOVE, MOVE],\n            [HEAL, HEAL, HEAL, MOVE, MOVE, MOVE]\n        ],\n        [ROLES.SCOUT]: [\n            [MOVE, MOVE],\n            [MOVE, MOVE, MOVE],\n            [MOVE, MOVE, MOVE, MOVE]\n        ]\n    };\n    \n    const roleBodies = bodies[role] || bodies[ROLES.HARVESTER];\n    \n    // Find the best body that fits energy budget\n    for (let i = roleBodies.length - 1; i >= 0; i--) {\n        const cost = roleBodies[i].reduce((sum, part) => sum + BODY_COSTS[part], 0);\n        if (cost <= energyAvailable) {\n            return roleBodies[i];\n        }\n    }\n    \n    return roleBodies[0]; // Fallback to cheapest\n}\n\n// Spawn management\nfunction manageSpawns() {\n    for (const spawnName in Game.spawns) {\n        const spawn = Game.spawns[spawnName];\n        \n        if (spawn.spawning) {\n            continue;\n        }\n        \n        const room = spawn.room;\n        const energyAvailable = room.energyAvailable;\n        const creeps = room.find(FIND_MY_CREEPS);\n        \n        // Priority system for PvP\n        const priorities = calculateSpawnPriorities(room, creeps, energyAvailable);\n        \n        for (const priority of priorities) {\n            if (spawnCreep(spawn, priority.role, priority.body)) {\n                console.log(`Spawning ${priority.role} in room ${room.name}`);\n                break;\n            }\n        }\n    }\n}\n\nfunction calculateSpawnPriorities(room, creeps, energyAvailable) {\n    const priorities = [];\n    const creepCounts = countCreepsByRole(creeps);\n    const enemyCreeps = room.find(FIND_HOSTILE_CREEPS);\n    const hasTower = room.find(FIND_MY_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_TOWER\n    }).length > 0;\n    \n    // EMERGENCY: No harvesters = spawn immediately\n    if (creepCounts[ROLES.HARVESTER] < 2) {\n        priorities.push({\n            role: ROLES.HARVESTER,\n            body: getBodyParts(ROLES.HARVESTER, energyAvailable),\n            priority: 100\n        });\n    }\n    \n    // PvP Defense: Enemy detected = spawn guards\n    if (enemyCreeps.length > 0) {\n        priorities.push({\n            role: ROLES.GUARD,\n            body: getBodyParts(ROLES.GUARD, energyAvailable),\n            priority: 90\n        });\n        \n        priorities.push({\n            role: ROLES.RANGER,\n            body: getBodyParts(ROLES.RANGER, energyAvailable),\n            priority: 85\n        });\n    }\n    \n    // Early game: Basic economy\n    if (room.controller.level <= 2) {\n        if (creepCounts[ROLES.HARVESTER] < 4) {\n            priorities.push({\n                role: ROLES.HARVESTER,\n                body: getBodyParts(ROLES.HARVESTER, energyAvailable),\n                priority: 80\n            });\n        }\n        \n        if (creepCounts[ROLES.BUILDER] < 2) {\n            priorities.push({\n                role: ROLES.BUILDER,\n                body: getBodyParts(ROLES.BUILDER, energyAvailable),\n                priority: 70\n            });\n        }\n        \n        if (creepCounts[ROLES.UPGRADER] < 2) {\n            priorities.push({\n                role: ROLES.UPGRADER,\n                body: getBodyParts(ROLES.UPGRADER, energyAvailable),\n                priority: 60\n            });\n        }\n    }\n    \n    // Mid game: Military focus\n    if (room.controller.level >= 3) {\n        if (creepCounts[ROLES.GUARD] < 3) {\n            priorities.push({\n                role: ROLES.GUARD,\n                body: getBodyParts(ROLES.GUARD, energyAvailable),\n                priority: 75\n            });\n        }\n        \n        if (creepCounts[ROLES.SCOUT] < 1) {\n            priorities.push({\n                role: ROLES.SCOUT,\n                body: getBodyParts(ROLES.SCOUT, energyAvailable),\n                priority: 70\n            });\n        }\n        \n        if (creepCounts[ROLES.ATTACKER] < 2) {\n            priorities.push({\n                role: ROLES.ATTACKER,\n                body: getBodyParts(ROLES.ATTACKER, energyAvailable),\n                priority: 65\n            });\n        }\n    }\n    \n    // Late game: Full military\n    if (room.controller.level >= 4) {\n        if (creepCounts[ROLES.HEALER] < 2) {\n            priorities.push({\n                role: ROLES.HEALER,\n                body: getBodyParts(ROLES.HEALER, energyAvailable),\n                priority: 60\n            });\n        }\n        \n        if (creepCounts[ROLES.RANGER] < 3) {\n            priorities.push({\n                role: ROLES.RANGER,\n                body: getBodyParts(ROLES.RANGER, energyAvailable),\n                priority: 55\n            });\n        }\n    }\n    \n    return priorities.sort((a, b) => b.priority - a.priority);\n}\n\nfunction countCreepsByRole(creeps) {\n    const counts = {};\n    for (const role of Object.values(ROLES)) {\n        counts[role] = creeps.filter(c => c.memory.role === role).length;\n    }\n    return counts;\n}\n\nfunction spawnCreep(spawn, role, body) {\n    const result = spawn.spawnCreep(body, `${role}_${Game.time}`, {\n        memory: {\n            role: role,\n            room: spawn.room.name,\n            working: false,\n            target: null\n        }\n    });\n    \n    return result === OK;\n}\n\n// Creep behavior management\nfunction manageCreeps() {\n    for (const name in Game.creeps) {\n        const creep = Game.creeps[name];\n        \n        switch (creep.memory.role) {\n            case ROLES.HARVESTER:\n                runHarvester(creep);\n                break;\n            case ROLES.BUILDER:\n                runBuilder(creep);\n                break;\n            case ROLES.UPGRADER:\n                runUpgrader(creep);\n                break;\n            case ROLES.REPAIRER:\n                runRepairer(creep);\n                break;\n            case ROLES.GUARD:\n                runGuard(creep);\n                break;\n            case ROLES.ATTACKER:\n                runAttacker(creep);\n                break;\n            case ROLES.RANGER:\n                runRanger(creep);\n                break;\n            case ROLES.HEALER:\n                runHealer(creep);\n                break;\n            case ROLES.SCOUT:\n                runScout(creep);\n                break;\n        }\n    }\n}\n\n// Economic roles\nfunction runHarvester(creep) {\n    if (creep.store.getFreeCapacity() === 0) {\n        // Full, go deposit\n        const target = findDepositTarget(creep);\n        if (target) {\n            if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target);\n            }\n        }\n    } else {\n        // Need to harvest\n        const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n        if (source) {\n            if (creep.harvest(source) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(source);\n            }\n        }\n    }\n}\n\nfunction runBuilder(creep) {\n    if (creep.store.getUsedCapacity() === 0) {\n        // Need energy\n        const source = findEnergySource(creep);\n        if (source) {\n            if (creep.withdraw(source, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(source);\n            }\n        }\n    } else {\n        // Build construction sites\n        const target = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n        if (target) {\n            if (creep.build(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target);\n            }\n        } else {\n            // No construction sites, help with repairs\n            runRepairer(creep);\n        }\n    }\n}\n\nfunction runUpgrader(creep) {\n    if (creep.store.getUsedCapacity() === 0) {\n        // Need energy\n        const source = findEnergySource(creep);\n        if (source) {\n            if (creep.withdraw(source, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(source);\n            }\n        }\n    } else {\n        // Upgrade controller\n        const controller = creep.room.controller;\n        if (controller) {\n            if (creep.upgradeController(controller) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(controller);\n            }\n        }\n    }\n}\n\nfunction runRepairer(creep) {\n    if (creep.store.getUsedCapacity() === 0) {\n        // Need energy\n        const source = findEnergySource(creep);\n        if (source) {\n            if (creep.withdraw(source, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(source);\n            }\n        }\n    } else {\n        // Find damaged structures (prioritize defense)\n        const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n            filter: s => (s.hits < s.hitsMax * 0.8) && \n                        (s.structureType === STRUCTURE_RAMPART || \n                         s.structureType === STRUCTURE_WALL ||\n                         s.structureType === STRUCTURE_TOWER)\n        });\n        \n        if (target) {\n            if (creep.repair(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target);\n            }\n        } else {\n            // Repair other structures\n            const otherTarget = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n                filter: s => s.hits < s.hitsMax * 0.5\n            });\n            \n            if (otherTarget) {\n                if (creep.repair(otherTarget) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(otherTarget);\n                }\n            }\n        }\n    }\n}\n\n// Military roles\nfunction runGuard(creep) {\n    const enemies = creep.room.find(FIND_HOSTILE_CREEPS);\n    \n    if (enemies.length > 0) {\n        const closestEnemy = creep.pos.findClosestByPath(enemies);\n        if (closestEnemy) {\n            if (creep.attack(closestEnemy) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(closestEnemy);\n            }\n        }\n    } else {\n        // Patrol near important structures\n        const spawn = creep.room.find(FIND_MY_SPAWNS)[0];\n        if (spawn) {\n            creep.moveTo(spawn.pos.x + Math.random() * 10 - 5, spawn.pos.y + Math.random() * 10 - 5);\n        }\n    }\n}\n\nfunction runAttacker(creep) {\n    // Find enemy spawns or creeps in adjacent rooms\n    const enemySpawn = creep.pos.findClosestByPath(FIND_HOSTILE_SPAWNS);\n    \n    if (enemySpawn) {\n        if (creep.attack(enemySpawn) === ERR_NOT_IN_RANGE) {\n            creep.moveTo(enemySpawn);\n        }\n    } else {\n        // Look for enemy creeps\n        const enemyCreep = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n        if (enemyCreep) {\n            if (creep.attack(enemyCreep) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemyCreep);\n            }\n        } else {\n            // Move to enemy room or patrol\n            exploreAndAttack(creep);\n        }\n    }\n}\n\nfunction runRanger(creep) {\n    const enemies = creep.room.find(FIND_HOSTILE_CREEPS);\n    \n    if (enemies.length > 0) {\n        // Attack from range\n        const target = creep.pos.findClosestByPath(enemies);\n        if (target) {\n            const range = creep.pos.getRangeTo(target);\n            \n            if (range <= 3) {\n                creep.rangedAttack(target);\n            } else {\n                creep.moveTo(target);\n            }\n            \n            // Mass attack if enemies are clustered\n            if (range <= 1) {\n                creep.rangedMassAttack();\n            }\n        }\n    } else {\n        // Support attackers or explore\n        const allies = creep.room.find(FIND_MY_CREEPS, {\n            filter: c => c.memory.role === ROLES.ATTACKER\n        });\n        \n        if (allies.length > 0) {\n            creep.moveTo(allies[0]);\n        } else {\n            exploreAndAttack(creep);\n        }\n    }\n}\n\nfunction runHealer(creep) {\n    // Heal damaged allies\n    const damagedAlly = creep.pos.findClosestByPath(FIND_MY_CREEPS, {\n        filter: c => c.hits < c.hitsMax\n    });\n    \n    if (damagedAlly) {\n        const range = creep.pos.getRangeTo(damagedAlly);\n        \n        if (range <= 1) {\n            creep.heal(damagedAlly);\n        } else {\n            creep.rangedHeal(damagedAlly);\n            creep.moveTo(damagedAlly);\n        }\n    } else {\n        // Follow military units\n        const military = creep.room.find(FIND_MY_CREEPS, {\n            filter: c => [ROLES.ATTACKER, ROLES.RANGER, ROLES.GUARD].includes(c.memory.role)\n        });\n        \n        if (military.length > 0) {\n            creep.moveTo(military[0]);\n        }\n    }\n}\n\nfunction runScout(creep) {\n    // Explore adjacent rooms\n    const exits = Game.map.describeExits(creep.room.name);\n    \n    if (exits) {\n        const directions = Object.values(exits);\n        const targetRoom = directions[Math.floor(Math.random() * directions.length)];\n        \n        if (creep.room.name !== targetRoom) {\n            const exitDir = creep.room.findExit(targetRoom);\n            const exit = creep.pos.findClosestByPath(exitDir);\n            \n            if (exit) {\n                creep.moveTo(exit);\n            }\n        } else {\n            // Scout current room\n            const enemyStructures = creep.room.find(FIND_HOSTILE_STRUCTURES);\n            const enemySpawns = creep.room.find(FIND_HOSTILE_SPAWNS);\n            \n            if (enemySpawns.length > 0) {\n                // Report back enemy spawn location\n                creep.memory.enemySpawn = enemySpawns[0].pos;\n            }\n            \n            // Move to unexplored areas\n            creep.moveTo(Math.random() * 49, Math.random() * 49);\n        }\n    }\n}\n\n// Helper functions\nfunction findEnergySource(creep) {\n    // Priority: Storage > Container > Spawn/Extension > Source\n    const storage = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_STORAGE && s.store[RESOURCE_ENERGY] > 0\n    })[0];\n    \n    if (storage) return storage;\n    \n    const container = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_CONTAINER && s.store[RESOURCE_ENERGY] > 0\n    })[0];\n    \n    if (container) return container;\n    \n    const spawnExtension = creep.room.find(FIND_STRUCTURES, {\n        filter: s => (s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION) && \n                    s.store[RESOURCE_ENERGY] > 0\n    })[0];\n    \n    if (spawnExtension) return spawnExtension;\n    \n    return creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n}\n\nfunction findDepositTarget(creep) {\n    // Priority: Spawn > Extension > Tower > Storage\n    const spawn = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_SPAWN && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n    })[0];\n    \n    if (spawn) return spawn;\n    \n    const extension = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_EXTENSION && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n    })[0];\n    \n    if (extension) return extension;\n    \n    const tower = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_TOWER && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n    })[0];\n    \n    if (tower) return tower;\n    \n    const storage = creep.room.find(FIND_STRUCTURES, {\n        filter: s => s.structureType === STRUCTURE_STORAGE && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n    })[0];\n    \n    if (storage) return storage;\n    \n    return null;\n}\n\nfunction exploreAndAttack(creep) {\n    // Move to adjacent rooms looking for enemies\n    const exits = Game.map.describeExits(creep.room.name);\n    \n    if (exits) {\n        const directions = Object.values(exits);\n        const targetRoom = directions[Math.floor(Math.random() * directions.length)];\n        \n        const exitDir = creep.room.findExit(targetRoom);\n        const exit = creep.pos.findClosestByPath(exitDir);\n        \n        if (exit) {\n            creep.moveTo(exit);\n        }\n    }\n}\n\n// Defense management\nfunction manageDefense() {\n    for (const roomName in Game.rooms) {\n        const room = Game.rooms[roomName];\n        \n        // Tower defense\n        const towers = room.find(FIND_MY_STRUCTURES, {\n            filter: s => s.structureType === STRUCTURE_TOWER\n        });\n        \n        for (const tower of towers) {\n            const closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n                filter: s => s.hits < s.hitsMax && \n                           (s.structureType === STRUCTURE_RAMPART || \n                            s.structureType === STRUCTURE_WALL ||\n                            s.structureType === STRUCTURE_TOWER)\n            });\n            \n            if (closestDamagedStructure) {\n                tower.repair(closestDamagedStructure);\n            }\n            \n            const closestEnemy = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n            if (closestEnemy) {\n                tower.attack(closestEnemy);\n            }\n        }\n        \n        // Build defensive structures\n        buildDefense(room);\n    }\n}\n\nfunction buildDefense(room) {\n    const controller = room.controller;\n    if (!controller || controller.level < 3) return;\n    \n    const spawn = room.find(FIND_MY_SPAWNS)[0];\n    if (!spawn) return;\n    \n    // Build ramparts around spawn\n    const spawnPos = spawn.pos;\n    for (let x = spawnPos.x - 2; x <= spawnPos.x + 2; x++) {\n        for (let y = spawnPos.y - 2; y <= spawnPos.y + 2; y++) {\n            if (x >= 0 && x < 50 && y >= 0 && y < 50) {\n                const pos = new RoomPosition(x, y, room.name);\n                const structures = pos.lookFor(LOOK_STRUCTURES);\n                \n                if (structures.length === 0 && !(x === spawnPos.x && y === spawnPos.y)) {\n                    room.createConstructionSite(x, y, STRUCTURE_RAMPART);\n                }\n            }\n        }\n    }\n    \n    // Build walls at room exits\n    if (controller.level >= 4) {\n        const exits = Game.map.describeExits(room.name);\n        if (exits) {\n            for (const [dir, targetRoom] of Object.entries(exits)) {\n                const exitPositions = room.find(parseInt(dir));\n                for (const pos of exitPositions.slice(0, 3)) {\n                    room.createConstructionSite(pos.x, pos.y, STRUCTURE_WALL);\n                }\n            }\n        }\n    }\n}\n\n// Main loop\nmodule.exports.loop = function () {\n    // Clear dead creeps memory\n    for (const name in Memory.creeps) {\n        if (!Game.creeps[name]) {\n            delete Memory.creeps[name];\n        }\n    }\n    \n    // Run all systems\n    manageSpawns();\n    manageCreeps();\n    manageDefense();\n    \n    // Emergency defense check\n    for (const roomName in Game.rooms) {\n        const room = Game.rooms[roomName];\n        const enemies = room.find(FIND_HOSTILE_CREEPS);\n        \n        if (enemies.length > 0) {\n            console.log(`ENEMY DETECTED in ${roomName}! ${enemies.length} hostile creeps`);\n            \n            // Emergency spawn guards\n            const spawn = room.find(FIND_MY_SPAWNS)[0];\n            if (spawn && !spawn.spawning) {\n                const guards = room.find(FIND_MY_CREEPS, {\n                    filter: c => c.memory.role === ROLES.GUARD\n                });\n                \n                if (guards.length < enemies.length * 2) {\n                    const body = getBodyParts(ROLES.GUARD, room.energyAvailable);\n                    spawnCreep(spawn, ROLES.GUARD, body);\n                }\n            }\n        }\n    }\n    \n    console.log(`Tick ${Game.time}: ${Object.keys(Game.creeps).length} creeps, ${Object.keys(Game.spawns).length} spawns`);\n};"
  }
}
EOF

# Try to upload without authentication first
echo "Attempting to upload code..."
curl -s -X POST "http://localhost:21025/api/user/code" \
  -H "Content-Type: application/json" \
  -d @/tmp/code.json

echo "Done."