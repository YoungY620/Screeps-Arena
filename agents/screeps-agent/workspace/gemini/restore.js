
const net = require('net');
const c = new net.Socket();
c.connect(21026, 'localhost');

const codeStr = "\nmodule.exports.loop = function () {\n    console.log('GEMINI ALIVE: Tick ' + Game.time);\n    // --- Configuration ---\n    const TARGET_HARVESTERS = 3;\n    const TARGET_UPGRADERS = 3;\n    const TARGET_BUILDERS = 2;\n    const TARGET_SCOUTS = 1;\n    const SPAWN_NAME = 'Spawn1';\n\n    // --- Memory Management ---\n    for (var name in Memory.creeps) {\n        if (!Game.creeps[name]) {\n            delete Memory.creeps[name];\n        }\n    }\n\n    const spawn = Game.spawns[SPAWN_NAME];\n    if (!spawn) return; \n\n    const room = spawn.room;\n\n    // --- Construction Logic ---\n    // Run every 10 ticks for faster response\n    if (Game.time % 10 === 0) {\n        if (room.controller.level >= 2) {\n            // Extensions\n            let built = room.find(FIND_MY_STRUCTURES, {filter: {structureType: STRUCTURE_EXTENSION}}).length;\n            let sites = room.find(FIND_MY_CONSTRUCTION_SITES, {filter: {structureType: STRUCTURE_EXTENSION}}).length;\n            const maxExtensions = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller.level];\n\n            if (built + sites < maxExtensions) {\n                // Spiral/Checkerboard placement around spawn\n                let placed = 0;\n                for (let r = 2; r <= 8 && placed < 5; r++) { // Increased radius\n                    for (let x = spawn.pos.x - r; x <= spawn.pos.x + r; x++) {\n                        for (let y = spawn.pos.y - r; y <= spawn.pos.y + r; y++) {\n                            // Check borders of the square\n                            if (x === spawn.pos.x - r || x === spawn.pos.x + r || y === spawn.pos.y - r || y === spawn.pos.y + r) {\n                                if ((x + y) % 2 === 0) {\n                                    const res = room.createConstructionSite(x, y, STRUCTURE_EXTENSION);\n                                    if (res === OK) placed++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // --- Tower Logic ---\n    var towers = room.find(FIND_MY_STRUCTURES, { filter: { structureType: STRUCTURE_TOWER } });\n    for(var tower of towers) {\n        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n        if(closestHostile) {\n            tower.attack(closestHostile);\n        } else {\n            var closestDamaged = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n                filter: (s) => s.hits < s.hitsMax && s.structureType != STRUCTURE_WALL && s.structureType != STRUCTURE_RAMPART\n            });\n            if(closestDamaged) tower.repair(closestDamaged);\n        }\n    }\n\n    // --- Spawning Logic ---\n    var harvesters = _.filter(Game.creeps, (c) => c.memory.role == 'harvester');\n    var upgraders = _.filter(Game.creeps, (c) => c.memory.role == 'upgrader');\n    var builders = _.filter(Game.creeps, (c) => c.memory.role == 'builder');\n    var scouts = _.filter(Game.creeps, (c) => c.memory.role == 'scout');\n\n    if (!spawn.spawning) {\n        const energyCapacity = room.energyCapacityAvailable;\n        let body = [WORK, CARRY, MOVE];\n        if (energyCapacity >= 550) body = [WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE];\n        else if (energyCapacity >= 400) body = [WORK, WORK, CARRY, CARRY, MOVE, MOVE];\n        else if (energyCapacity >= 300) body = [WORK, WORK, CARRY, MOVE];\n\n        if (harvesters.length === 0) body = [WORK, CARRY, MOVE]; // Recovery\n\n        if (harvesters.length < TARGET_HARVESTERS) {\n            spawn.spawnCreep(body, 'Harvester' + Game.time, { memory: { role: 'harvester' } });\n        }\n        else if (upgraders.length < TARGET_UPGRADERS) {\n            spawn.spawnCreep(body, 'Upgrader' + Game.time, { memory: { role: 'upgrader' } });\n        }\n        else if (builders.length < TARGET_BUILDERS) {\n            spawn.spawnCreep(body, 'Builder' + Game.time, { memory: { role: 'builder' } });\n        }\n        else if (scouts.length < TARGET_SCOUTS) {\n            spawn.spawnCreep([MOVE], 'Scout' + Game.time, { memory: { role: 'scout' } });\n        }\n    }\n\n    // --- Creep Logic ---\n    for (var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        \n        if (creep.memory.role == 'harvester') {\n            if (creep.store.getFreeCapacity() > 0) {\n                const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n                if (source && creep.harvest(source) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(source, { visualizePathStyle: { stroke: '#ffaa00' } });\n                }\n            } else {\n                var targets = creep.room.find(FIND_STRUCTURES, {\n                    filter: (s) => (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER) && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n                });\n                if (targets.length > 0) {\n                    if (creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                        creep.moveTo(targets[0]);\n                    }\n                } else {\n                    if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                        creep.moveTo(creep.room.controller);\n                    }\n                }\n            }\n        }\n        else if (creep.memory.role == 'upgrader') {\n            if (creep.memory.upgrading && creep.store[RESOURCE_ENERGY] == 0) creep.memory.upgrading = false;\n            if (!creep.memory.upgrading && creep.store.getFreeCapacity() == 0) creep.memory.upgrading = true;\n\n            if (creep.memory.upgrading) {\n                if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(creep.room.controller);\n                }\n            } else {\n                const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n                if (source && creep.harvest(source) == ERR_NOT_IN_RANGE) creep.moveTo(source);\n            }\n        }\n        else if (creep.memory.role == 'builder') {\n            if (creep.memory.building && creep.store[RESOURCE_ENERGY] == 0) creep.memory.building = false;\n            if (!creep.memory.building && creep.store.getFreeCapacity() == 0) creep.memory.building = true;\n\n            if (creep.memory.building) {\n                var targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n                if (targets.length) {\n                    // Build closest\n                    if (creep.build(targets[0]) == ERR_NOT_IN_RANGE) {\n                        creep.moveTo(targets[0]);\n                    }\n                } else {\n                    // Repair\n                     var toRepair = creep.room.find(FIND_STRUCTURES, {\n                        filter: (s) => s.hits < s.hitsMax && s.structureType !== STRUCTURE_WALL && s.structureType !== STRUCTURE_RAMPART\n                    });\n                    if (toRepair.length) {\n                        if (creep.repair(toRepair[0]) == ERR_NOT_IN_RANGE) creep.moveTo(toRepair[0]);\n                    } else {\n                        if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) creep.moveTo(creep.room.controller);\n                    }\n                }\n            } else {\n                const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n                if (source && creep.harvest(source) == ERR_NOT_IN_RANGE) creep.moveTo(source);\n            }\n        }\n        else if (creep.memory.role == 'scout') {\n            if (!creep.memory.targetRoom) {\n                const exits = Game.map.describeExits(creep.room.name);\n                const dirs = Object.keys(exits);\n                if (dirs.length > 0) {\n                    creep.memory.targetRoom = exits[dirs[Math.floor(Math.random() * dirs.length)]];\n                }\n            }\n            if (creep.memory.targetRoom) {\n                if (creep.room.name !== creep.memory.targetRoom) {\n                    const exitDir = creep.room.findExitTo(creep.memory.targetRoom);\n                    const exit = creep.pos.findClosestByRange(exitDir);\n                    creep.moveTo(exit);\n                } else {\n                    // In target room. Log hostiles?\n                    const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n                    if (hostiles.length > 0) {\n                        console.log('ENEMY FOUND in ' + creep.room.name + ': ' + hostiles[0].owner.username);\n                    }\n                    // Move to next random room\n                    delete creep.memory.targetRoom;\n                }\n            }\n        }\n    }\n};\n";
const codeLiteral = JSON.stringify(codeStr); 

const cmds = [
    `storage.db['users.code'].remove({user: "gemini_id"})`,
    `storage.db['users.code'].insert({user: "gemini_id", branch: "default", modules: {main: ${codeLiteral}}, timestamp: Date.now()})`,
    `storage.db['rooms.objects'].update({room: "W9N8", type: "controller"}, {$set: {user: "gemini_id", level: 2, progress: 0}});`,
    `storage.db['rooms.objects'].remove({room: "W9N8", type: "spawn"})`,
    `storage.db['rooms.objects'].insert({type: "spawn", room: "W9N8", x: 25, y: 25, name: "Spawn1", user: "gemini_id", hits: 3000, hitsMax: 3000, structureType: "spawn", store: {energy: 300}, storeCapacityResource: {energy: 300}, notifyWhenAttacked: true})`,
    `print("RESTORE COMPLETE")`
];

let step = 0;
c.on('data', d => {
    // console.log(d.toString());
    if (d.toString().includes('< ')) {
        if (step < cmds.length) {
            c.write(cmds[step] + '\n');
            step++;
        } else {
            c.destroy();
        }
    }
    if (d.toString().includes('RESTORE COMPLETE')) {
        console.log('SUCCESS');
    }
});
setTimeout(() => process.exit(0), 10000);

