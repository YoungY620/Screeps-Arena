{"branch":"default","modules":{"main":"// üèÜ SCREEPS ULTIMATE PvP DOMINATION AI v6.0 üèÜ\n// TOTAL ANNIHILATION EDITION - Supreme Battlefield Control\n\nconst DOMINATION_MODE = {\n    PEACETIME: 0,\n    SURVEILLANCE: 1,\n    THREAT_DETECTED: 2,\n    ACTIVE_DEFENSE: 3,\n    OFFENSIVE_OPERATIONS: 4,\n    TOTAL_WAR: 5,\n    ANNIHILATION: 6,\n    DOMINATION: 7\n};\n\nlet dominationState = {\n    mode: DOMINATION_MODE.SURVEILLANCE,\n    lastEnemyContact: 0,\n    currentTick: 0,\n    roomName: 'W1N3',\n    spawnPositions: [{x: 33, y: 16}, {x: 34, y: 17}, {x: 34, y: 16}],\n    enemies: [],\n    allies: [],\n    hostileRooms: new Set(),\n    attackQueue: [],\n    intelligenceReports: new Map(),\n    battleRecord: {kills: 0, losses: 0, raids: 0, victories: 0},\n    economicPhase: 'expansion',\n    militaryPhase: 'preparation',\n    dominationDeclared: false,\n    supremeCommander: false\n};\n\n// SUPREME military unit designs - Ultimate destruction machines\nconst supremeBodies = {\n    // Reconnaissance\n    scout: [MOVE, MOVE, MOVE, MOVE, MOVE], // Lightning fast\n    \n    // Infantry\n    warrior: [TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Ranged Support\n    archer: [TOUGH, TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Medical Support\n    medic: [TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Heavy Assault\n    destroyer: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Siege Artillery\n    siege: [TOUGH, TOUGH, TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Suicide Bombers\n    kamikaze: [MOVE, MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK], // Pure annihilation\n    \n    // Elite Assassins\n    assassin: [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK], // Lightning execution\n    \n    // Ultimate War Machines\n    annihilator: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    // Supreme Commanders\n    commander: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE]\n};\n\n// SUPREME role system - Total battlefield dominance\nconst supremeRoles = {\n    // Economic Foundation\n    harvester: {\n        body: [WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 12,\n        priority: 1,\n        emergencyCount: 6,\n        economic: true\n    },\n    \n    upgrader: {\n        body: [WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 8,\n        priority: 2,\n        emergencyCount: 4,\n        economic: true\n    },\n    \n    transporter: {\n        body: [CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE],\n        maxCount: 6,\n        priority: 3,\n        emergencyCount: 3,\n        economic: true\n    },\n    \n    builder: {\n        body: [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 6,\n        priority: 4,\n        emergencyCount: 3,\n        economic: true\n    },\n    \n    repairer: {\n        body: [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 4,\n        priority: 5,\n        emergencyCount: 2,\n        economic: true\n    },\n    \n    // Intelligence Operations\n    scout: {\n        body: supremeBodies.scout,\n        maxCount: 4,\n        priority: 6,\n        emergencyCount: 2,\n        military: true\n    },\n    \n    infiltrator: {\n        body: [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE], // Ultra stealthy\n        maxCount: 2,\n        priority: 7,\n        emergencyCount: 1,\n        military: true\n    },\n    \n    // Ground Forces\n    warrior: {\n        body: supremeBodies.warrior,\n        maxCount: 8,\n        priority: 8,\n        emergencyCount: 5,\n        military: true\n    },\n    \n    archer: {\n        body: supremeBodies.archer,\n        maxCount: 8,\n        priority: 9,\n        emergencyCount: 5,\n        military: true\n    },\n    \n    guardian: {\n        body: [TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, MOVE, MOVE, MOVE], // Defensive specialist\n        maxCount: 6,\n        priority: 10,\n        emergencyCount: 4,\n        military: true\n    },\n    \n    // Special Operations\n    assassin: {\n        body: supremeBodies.assassin,\n        maxCount: 4,\n        priority: 11,\n        emergencyCount: 2,\n        military: true\n    },\n    \n    kamikaze: {\n        body: supremeBodies.kamikaze,\n        maxCount: 6,\n        priority: 12,\n        emergencyCount: 3,\n        military: true\n    },\n    \n    // Heavy Assault\n    destroyer: {\n        body: supremeBodies.destroyer,\n        maxCount: 6,\n        priority: 13,\n        emergencyCount: 4,\n        military: true\n    },\n    \n    siege: {\n        body: supremeBodies.siege,\n        maxCount: 6,\n        priority: 14,\n        emergencyCount: 4,\n        military: true\n    },\n    \n    // Support Units\n    medic: {\n        body: supremeBodies.medic,\n        maxCount: 4,\n        priority: 15,\n        emergencyCount: 3,\n        military: true\n    },\n    \n    // Elite Forces\n    annihilator: {\n        body: supremeBodies.annihilator,\n        maxCount: 4,\n        priority: 16,\n        emergencyCount: 2,\n        military: true\n    },\n    \n    commander: {\n        body: supremeBodies.commander,\n        maxCount: 2,\n        priority: 17,\n        emergencyCount: 1,\n        military: true\n    }\n};\n\n// SUPREME defense system - Impregnable fortress of supremacy\nconst supremeDefense = {\n    buildSupremeFortress: function(room) {\n        // Build multi-layered defensive rings around all spawns\n        const spawns = room.find(FIND_MY_SPAWNS);\n        \n        spawns.forEach((spawn, spawnIndex) => {\n            // Layer 1: Inner sanctum (3x3 around spawn)\n            for (let radius = 2; radius <= 4; radius++) {\n                for (let x = spawn.pos.x - radius; x <= spawn.pos.x + radius; x++) {\n                    for (let y = spawn.pos.y - radius; y <= spawn.pos.y + radius; y++) {\n                        if (Math.abs(x - spawn.pos.x) === radius || Math.abs(y - spawn.pos.y) === radius) {\n                            const structures = room.lookForAt(LOOK_STRUCTURES, x, y);\n                            const hasWall = structures.some(s => s.structureType === STRUCTURE_RAMPART);\n                            \n                            if (!hasWall) {\n                                if (room.createConstructionSite(x, y, STRUCTURE_RAMPART) === OK) {\n                                    console.log(`üè∞ SUPREME Fortress Layer${radius} at ${x},${y}`);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    },\n    \n    buildSupremeTowers: function(room) {\n        const spawns = room.find(FIND_MY_SPAWNS);\n        if (spawns.length === 0) return;\n        \n        // Calculate center point of all spawns\n        let centerX = spawns.reduce((sum, spawn) => sum + spawn.pos.x, 0) / spawns.length;\n        let centerY = spawns.reduce((sum, spawn) => sum + spawn.pos.y, 0) / spawns.length;\n        \n        const towerPositions = [\n            // Inner ring (5x5 from center)\n            {x: centerX - 5, y: centerY - 5}, {x: centerX, y: centerY - 5}, {x: centerX + 5, y: centerY - 5},\n            {x: centerX - 5, y: centerY}, {x: centerX + 5, y: centerY},\n            {x: centerX - 5, y: centerY + 5}, {x: centerX, y: centerY + 5}, {x: centerX + 5, y: centerY + 5},\n            // Outer ring (8x8 from center)\n            {x: centerX - 8, y: centerY - 8}, {x: centerX - 4, y: centerY - 8}, {x: centerX + 4, y: centerY - 8}, {x: centerX + 8, y: centerY - 8},\n            {x: centerX - 8, y: centerY - 4}, {x: centerX + 8, y: centerY - 4},\n            {x: centerX - 8, y: centerY + 4}, {x: centerX + 8, y: centerY + 4},\n            {x: centerX - 8, y: centerY + 8}, {x: centerX - 4, y: centerY + 8}, {x: centerX + 4, y: centerY + 8}, {x: centerX + 8, y: centerY + 8}\n        ];\n        \n        towerPositions.forEach(pos => {\n            const x = Math.round(pos.x);\n            const y = Math.round(pos.y);\n            if (room.createConstructionSite(x, y, STRUCTURE_TOWER) === OK) {\n                console.log(`üèóÔ∏è SUPREME Tower at ${x},${y}`);\n            }\n        });\n    },\n    \n    buildSupremeExtensions: function(room) {\n        const spawns = room.find(FIND_MY_SPAWNS);\n        if (spawns.length === 0) return;\n        \n        // Build extensions in organized clusters around spawns\n        spawns.forEach((spawn, index) => {\n            const clusterRadius = 8 + (index * 2); // Different radius for each spawn\n            \n            for (let x = spawn.pos.x - clusterRadius; x <= spawn.pos.x + clusterRadius; x++) {\n                for (let y = spawn.pos.y - clusterRadius; y <= spawn.pos.y + clusterRadius; y++) {\n                    const distance = Math.abs(x - spawn.pos.x) + Math.abs(y - spawn.pos.y);\n                    if (distance > 3 && distance <= clusterRadius) {\n                        if (room.createConstructionSite(x, y, STRUCTURE_EXTENSION) === OK) {\n                            console.log(`üîã SUPREME Extension Cluster${index} at ${x},${y}`);\n                        }\n                    }\n                }\n            }\n        });\n    },\n    \n    activateSupremeTowers: function(room) {\n        const towers = room.find(FIND_MY_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        });\n        \n        let enemiesEliminated = 0;\n        let alliesHealed = 0;\n        \n        towers.forEach((tower, index) => {\n            // SUPREME PRIORITY: Execute enemy healers with extreme prejudice\n            const hostileHealers = tower.room.find(FIND_HOSTILE_CREEPS, {\n                filter: hostile => hostile.getActiveBodyparts(HEAL) > 0\n            });\n            \n            if (hostileHealers.length > 0) {\n                const target = tower.pos.findClosestByRange(hostileHealers);\n                if (target) {\n                    tower.attack(target);\n                    console.log(`üí• SUPREME Tower${index} EXECUTING healer!`);\n                    enemiesEliminated++;\n                    return;\n                }\n            }\n            \n            // Target enemy commanders\n            const enemyCommanders = tower.room.find(FIND_HOSTILE_CREEPS, {\n                filter: hostile => hostile.name && hostile.name.includes('commander')\n            });\n            \n            if (enemyCommanders.length > 0) {\n                tower.attack(enemyCommanders[0]);\n                console.log(`üëë SUPREME Tower${index} ASSASSINATING commander!`);\n                enemiesEliminated++;\n                return;\n            }\n            \n            // Target enemy spawns\n            const enemySpawns = tower.room.find(FIND_HOSTILE_SPAWNS);\n            if (enemySpawns.length > 0) {\n                const target = tower.pos.findClosestByRange(enemySpawns);\n                if (target) {\n                    tower.attack(target);\n                    console.log(`üè¥‚Äç‚ò†Ô∏è SUPREME Tower${index} DESTROYING enemy spawn!`);\n                    enemiesEliminated++;\n                    return;\n                }\n            }\n            \n            // Execute dangerous enemies\n            const dangerousEnemies = tower.room.find(FIND_HOSTILE_CREEPS, {\n                filter: hostile => {\n                    return hostile.getActiveBodyparts(ATTACK) > 2 || hostile.getActiveBodyparts(RANGED_ATTACK) > 2;\n                }\n            });\n            \n            if (dangerousEnemies.length > 0) {\n                const target = tower.pos.findClosestByRange(dangerousEnemies);\n                if (target) {\n                    tower.attack(target);\n                    console.log(`‚öîÔ∏è SUPREME Tower${index} ELIMINATING dangerous hostile!`);\n                    enemiesEliminated++;\n                    return;\n                }\n            }\n            \n            // Eliminate any hostile\n            const closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n            if (closestHostile) {\n                tower.attack(closestHostile);\n                console.log(`‚öîÔ∏è SUPREME Tower${index} ATTACKING hostile`);\n                enemiesEliminated++;\n                return;\n            }\n            \n            // Heal military allies with priority\n            const militaryAllies = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n                filter: creep => {\n                    return (creep.memory.role === 'warrior' || creep.memory.role === 'archer' || \n                           creep.memory.role === 'destroyer' || creep.memory.role === 'annihilator' || \n                           creep.memory.role === 'commander') && creep.hits < creep.hitsMax * 0.8;\n                }\n            });\n            \n            if (militaryAllies) {\n                tower.heal(militaryAllies);\n                console.log(`üíö SUPREME Tower${index} MENDING military ally`);\n                alliesHealed++;\n                return;\n            }\n            \n            // Heal any damaged ally\n            const damagedAlly = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n                filter: creep => creep.hits < creep.hitsMax * 0.5;\n            });\n            \n            if (damagedAlly) {\n                tower.heal(damagedAlly);\n                console.log(`üíö SUPREME Tower${index} HEALING ally`);\n                alliesHealed++;\n            }\n        });\n        \n        return {enemiesEliminated, alliesHealed};\n    }\n};\n\n// SUPREME intelligence network - Know your enemy\nconst supremeIntelligence = {\n    gatherIntelligence: function(creep) {\n        if (!creep.room.controller || creep.room.controller.my) return; // Don't spy on own room\n        \n        const roomName = creep.room.name;\n        const report = {\n            room: roomName,\n            timestamp: Game.time,\n            hostiles: [],\n            structures: [],\n            spawns: [],\n            towers: [],\n            extensions: [],\n            threatLevel: 0,\n            economicLevel: 0,\n            militaryStrength: 0\n        };\n        \n        // Analyze enemy creeps\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        report.hostiles = hostiles.map(creep => ({\n            name: creep.name,\n            body: creep.body.map(part => part.type),\n            hits: creep.hits,\n            hitsMax: creep.hitsMax,\n            attackParts: creep.getActiveBodyparts(ATTACK),\n            rangedParts: creep.getActiveBodyparts(RANGED_ATTACK),\n            healParts: creep.getActiveBodyparts(HEAL),\n            toughParts: creep.getActiveBodyparts(TOUGH)\n        }));\n        \n        // Analyze enemy structures\n        const enemyStructures = creep.room.find(FIND_HOSTILE_STRUCTURES);\n        report.structures = enemyStructures.length;\n        report.spawns = enemyStructures.filter(s => s.structureType === STRUCTURE_SPAWN).length;\n        report.towers = enemyStructures.filter(s => s.structureType === STRUCTURE_TOWER).length;\n        report.extensions = enemyStructures.filter(s => s.structureType === STRUCTURE_EXTENSION).length;\n        \n        // Calculate threat level\n        const totalAttackParts = report.hostiles.reduce((sum, h) => sum + h.attackParts, 0);\n        const totalRangedParts = report.hostiles.reduce((sum, h) => sum + h.rangedParts, 0);\n        const totalHealParts = report.hostiles.reduce((sum, h) => sum + h.healParts, 0);\n        \n        report.militaryStrength = totalAttackParts + totalRangedParts + (totalHealParts * 0.5);\n        report.threatLevel = report.spawns * 10 + report.towers * 5 + report.militaryStrength;\n        report.economicLevel = report.extensions;\n        \n        // Store intelligence report\n        dominationState.intelligenceReports.set(roomName, report);\n        dominationState.hostileRooms.add(roomName);\n        \n        console.log(`üïµÔ∏è Intelligence gathered for ${roomName}: ${report.hostiles.length} hostiles, Threat: ${report.threatLevel}`);\n        \n        // Prioritize attack targets based on intelligence\n        if (report.threatLevel > 0) {\n            const priority = Math.max(1, Math.min(10, report.threatLevel));\n            dominationState.attackQueue.push({\n                room: roomName,\n                priority: priority,\n                threat: report.threatLevel,\n                spawns: report.spawns,\n                towers: report.towers\n            });\n        }\n    },\n    \n    selectPriorityTarget: function() {\n        if (dominationState.attackQueue.length === 0) return null;\n        \n        // Sort by priority (highest first)\n        dominationState.attackQueue.sort((a, b) => b.priority - a.priority);\n        \n        // Return highest priority target\n        return dominationState.attackQueue[0];\n    },\n    \n    getRecentReports: function(maxAge = 1000) {\n        const recent = [];\n        const currentTime = Game.time;\n        \n        for (const [room, report] of dominationState.intelligenceReports) {\n            if (currentTime - report.timestamp <= maxAge) {\n                recent.push(report);\n            }\n        }\n        \n        return recent;\n    }\n};\n\n// SUPREME military operations - Total enemy annihilation\nconst supremeMilitary = {\n    launchSupremeAttack: function(targetInfo) {\n        if (!targetInfo) return;\n        \n        console.log(`üöÄüåã LAUNCHING SUPREME ATTACK ON ${targetInfo.room}! Priority: ${targetInfo.priority}`);\n        \n        // Analyze available forces\n        const militaryUnits = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return supremeRoles[creep.memory.role] && supremeRoles[creep.memory.role].military && \n                   creep.room.name === dominationState.roomName;\n        });\n        \n        const forceComposition = {\n            warriors: 0,\n            archers: 0,\n            destroyers: 0,\n            siege: 0,\n            kamikaze: 0,\n            assassins: 0,\n            annihilators: 0,\n            medics: 0,\n            totalPower: 0\n        };\n        \n        militaryUnits.forEach(name => {\n            const creep = Game.creeps[name];\n            const role = creep.memory.role;\n            \n            switch(role) {\n                case 'warrior': forceComposition.warriors++; break;\n                case 'archer': forceComposition.archers++; break;\n                case 'destroyer': forceComposition.destroyers++; break;\n                case 'siege': forceComposition.siege++; break;\n                case 'kamikaze': forceComposition.kamikaze++; break;\n                case 'assassin': forceComposition.assassins++; break;\n                case 'annihilator': forceComposition.annihilators++; break;\n                case 'medic': forceComposition.medics++; break;\n            }\n        });\n        \n        // Calculate total attack power\n        forceComposition.totalPower = \n            forceComposition.warriors * 2 + \n            forceComposition.archers * 1.5 + \n            forceComposition.destroyers * 3 + \n            forceComposition.siege * 2.5 + \n            forceComposition.kamikaze * 2 + \n            forceComposition.assassins * 1.5 + \n            forceComposition.annihilators * 4;\n        \n        console.log(`üìä SUPREME Force Composition: ${JSON.stringify(forceComposition)}`);\n        \n        // Launch coordinated assault only if we have sufficient forces\n        if (forceComposition.totalPower >= 5) {\n            // Deploy forces in tactical waves\n            const assaultWave = [];\n            \n            // First wave: Heavy hitters and kamikaze\n            militaryUnits.forEach(name => {\n                const creep = Game.creeps[name];\n                if (['destroyer', 'annihilator', 'kamikaze'].includes(creep.memory.role)) {\n                    assaultWave.push(name);\n                }\n            });\n            \n            // Second wave: Warriors and siege\n            militaryUnits.forEach(name => {\n                const creep = Game.creeps[name];\n                if (['warrior', 'siege'].includes(creep.memory.role) && !assaultWave.includes(name)) {\n                    assaultWave.push(name);\n                }\n            });\n            \n            // Third wave: Support units\n            militaryUnits.forEach(name => {\n                const creep = Game.creeps[name];\n                if (['archer', 'assassin', 'medic'].includes(creep.memory.role) && !assaultWave.includes(name)) {\n                    assaultWave.push(name);\n                }\n            });\n            \n            // Deploy the assault wave\n            assaultWave.forEach((name, index) => {\n                const creep = Game.creeps[name];\n                creep.memory.targetRoom = targetInfo.room;\n                creep.memory.assaultRole = creep.memory.role;\n                creep.memory.assaultWave = Math.floor(index / 3) + 1; // Group in waves of 3\n                creep.memory.mode = 'assault';\n                \n                console.log(`üéØ ${name} assigned to ASSAULT WAVE ${creep.memory.assaultWave} on ${targetInfo.room}`);\n            });\n            \n            dominationState.battleRecord.raids++;\n            console.log(`üåã SUPREME ASSAULT DEPLOYED: ${assaultWave.length} units in ${Math.ceil(assaultWave.length / 3)} waves`);\n            \n            return true;\n        } else {\n            console.log(`‚è≥ Insufficient forces for SUPREME assault. Need more power.`);\n            return false;\n        }\n    },\n    \n    executeTacticalRetreat: function(creep) {\n        // Emergency retreat protocol\n        if (creep.hits < creep.hitsMax * 0.3) {\n            console.log(`üèÉ ${creep.name} executing tactical retreat`);\n            \n            // Find nearest ally or safe position\n            const allies = creep.room.find(FIND_MY_CREEPS, {\n                filter: ally => ally.hits > ally.hitsMax * 0.7\n            });\n            \n            if (allies.length > 0) {\n                creep.moveTo(allies[0]);\n            } else {\n                // Move to tower for protection\n                const towers = creep.room.find(FIND_MY_STRUCTURES, {\n                    filter: { structureType: STRUCTURE_TOWER }\n                });\n                \n                if (towers.length > 0) {\n                    creep.moveTo(towers[0]);\n                }\n            }\n            \n            // Self-heal if possible\n            if (creep.getActiveBodyparts(HEAL) > 0) {\n                creep.heal(creep);\n            }\n            \n            return true;\n        }\n        return false;\n    }\n};\n\n// SUPREME role execution - Elite battlefield performance\nconst supremeExecution = {\n    harvester: function(creep) {\n        // Supreme resource extraction\n        if (creep.store.getFreeCapacity() > 0) {\n            const sources = creep.room.find(FIND_SOURCES);\n            if (sources.length > 0) {\n                const targetSource = creep.pos.findClosestByPath(sources);\n                if (creep.harvest(targetSource) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targetSource, {visualizePathStyle: {stroke: '#ffaa00'}});\n                }\n            }\n        } else {\n            // Supreme resource distribution\n            const targets = creep.room.find(FIND_STRUCTURES, {\n                filter: (structure) => {\n                    return (structure.structureType === STRUCTURE_EXTENSION ||\n                            structure.structureType === STRUCTURE_SPAWN ||\n                            structure.structureType === STRUCTURE_TOWER) &&\n                            structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                }\n            });\n            \n            if (targets.length > 0) {\n                const target = creep.pos.findClosestByPath(targets);\n                if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(target, {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        }\n    },\n    \n    upgrader: function(creep) {\n        // Supreme controller enhancement\n        if (creep.store[RESOURCE_ENERGY] === 0) {\n            const sources = creep.room.find(FIND_SOURCES);\n            if (sources.length > 0) {\n                const targetSource = creep.pos.findClosestByPath(sources);\n                if (creep.harvest(targetSource) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targetSource, {visualizePathStyle: {stroke: '#ffaa00'}});\n                }\n            }\n        } else {\n            if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#ffffff'}});\n            }\n        }\n    },\n    \n    transporter: function(creep) {\n        // Supreme logistics network\n        if (creep.store[RESOURCE_ENERGY] === 0) {\n            // Collect energy from storage or dropped resources\n            const storage = creep.room.storage;\n            if (storage && storage.store[RESOURCE_ENERGY] > 0) {\n                if (creep.withdraw(storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(storage);\n                }\n                return;\n            }\n            \n            // Fallback to sources\n            const sources = creep.room.find(FIND_SOURCES);\n            if (sources.length > 0) {\n                const targetSource = creep.pos.findClosestByPath(sources);\n                if (creep.harvest(targetSource) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targetSource);\n                }\n            }\n        } else {\n            // Deliver to priority targets\n            const priorityTargets = creep.room.find(FIND_STRUCTURES, {\n                filter: s => (s.structureType === STRUCTURE_TOWER && s.store.getFreeCapacity(RESOURCE_ENERGY) > 200) ||\n                           (s.structureType === STRUCTURE_SPAWN && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0)\n            });\n            \n            if (priorityTargets.length > 0) {\n                const target = creep.pos.findClosestByPath(priorityTargets);\n                if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(target);\n                }\n                return;\n            }\n            \n            // Standard delivery\n            const targets = creep.room.find(FIND_STRUCTURES, {\n                filter: s => (s.structureType === STRUCTURE_EXTENSION || s.structureType === STRUCTURE_SPAWN) &&\n                           s.store.getFreeCapacity(RESOURCE_ENERGY) > 0\n            });\n            \n            if (targets.length > 0) {\n                const target = creep.pos.findClosestByPath(targets);\n                if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(target);\n                }\n            }\n        }\n    },\n    \n    builder: function(creep) {\n        // Supreme construction operations\n        const targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n        if (targets.length) {\n            if (creep.store[RESOURCE_ENERGY] === 0) {\n                const sources = creep.room.find(FIND_SOURCES);\n                if (sources.length > 0) {\n                    const targetSource = creep.pos.findClosestByPath(sources);\n                    if (creep.harvest(targetSource) === ERR_NOT_IN_RANGE) {\n                        creep.moveTo(targetSource, {visualizePathStyle: {stroke: '#ffaa00'}});\n                    }\n                }\n            } else {\n                // Prioritize military constructions\n                const militarySites = targets.filter(site => {\n                    return site.structureType === STRUCTURE_TOWER ||\n                           site.structureType === STRUCTURE_RAMPART;\n                });\n                \n                const targetSite = militarySites.length > 0 ? \n                    creep.pos.findClosestByPath(militarySites) : \n                    creep.pos.findClosestByPath(targets);\n                \n                if (creep.build(targetSite) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targetSite, {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        } else {\n            // No construction, help as transporter\n            supremeExecution.transporter(creep);\n        }\n    },\n    \n    repairer: function(creep) {\n        // Supreme maintenance operations\n        const targets = creep.room.find(FIND_STRUCTURES, {\n            filter: object => object.hits < object.hitsMax && \n                           object.structureType !== STRUCTURE_WALL &&\n                           object.structureType !== STRUCTURE_RAMPART\n        });\n        \n        targets.sort((a, b) => a.hits - b.hits);\n        \n        if (targets.length > 0) {\n            if (creep.store[RESOURCE_ENERGY] === 0) {\n                const sources = creep.room.find(FIND_SOURCES);\n                if (sources.length > 0) {\n                    const targetSource = creep.pos.findClosestByPath(sources);\n                    if (creep.harvest(targetSource) === ERR_NOT_IN_RANGE) {\n                        creep.moveTo(targetSource, {visualizePathStyle: {stroke: '#ffaa00'}});\n                    }\n                }\n            } else {\n                const target = creep.pos.findClosestByPath(targets);\n                if (creep.repair(target) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(target, {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        } else {\n            // No repairs needed, help as builder\n            supremeExecution.builder(creep);\n        }\n    },\n    \n    scout: function(creep) {\n        // Supreme intelligence gathering\n        const hostileRooms = Array.from(dominationState.hostileRooms);\n        const potentialTargets = ['W1N1', 'W1N2', 'W1N4', 'W1N5', 'W2N1', 'W2N2', 'W2N3', 'W0N1', 'W0N2', 'W0N3', 'W3N1', 'W3N2', 'W3N3', 'W4N1', 'W4N2'];\n        \n        // Prioritize known hostile rooms\n        const targetRooms = hostileRooms.length > 0 ? hostileRooms : potentialTargets;\n        const targetRoom = targetRooms[Math.floor(Math.random() * targetRooms.length)];\n        \n        if (creep.room.name !== targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, targetRoom), {visualizePathStyle: {stroke: '#00ff00'}});\n            return;\n        }\n        \n        // Gather intelligence\n        supremeIntelligence.gatherIntelligence(creep);\n        \n        // Evade detection by constantly moving\n        creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n    },\n    \n    infiltrator: function(creep) {\n        // Deep penetration intelligence\n        const targetRooms = ['W4N4', 'W5N5', 'W6N6', 'W7N7', 'W8N8', 'W9N9', 'W10N10'];\n        const targetRoom = targetRooms[Math.floor(Math.random() * targetRooms.length)];\n        \n        if (creep.room.name !== targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, targetRoom), {visualizePathStyle: {stroke: '#00ff00'}});\n            return;\n        }\n        \n        // Quick intelligence sweep\n        supremeIntelligence.gatherIntelligence(creep);\n        \n        // Rapid evacuation\n        creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n    },\n    \n    warrior: function(creep) {\n        // Supreme infantry combat\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if critically damaged\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        // Engage enemies with supreme efficiency\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            // Prioritize healers first\n            const enemyHealers = hostiles.filter(h => h.getActiveBodyparts(HEAL) > 0);\n            const target = enemyHealers.length > 0 ? \n                creep.pos.findClosestByRange(enemyHealers) : \n                creep.pos.findClosestByRange(hostiles);\n            \n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n        } else if (creep.memory.mode === 'assault') {\n            // Move to assault position\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n        } else {\n            // Patrol mode\n            creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n        }\n    },\n    \n    archer: function(creep) {\n        // Supreme ranged combat\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if needed\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            \n            if (creep.rangedAttack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                // Use mass attack if multiple enemies in range\n                if (hostiles.length > 2 && creep.pos.getRangeTo(target) <= 3) {\n                    creep.rangedMassAttack();\n                }\n            }\n        } else if (creep.memory.mode === 'assault') {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n        } else {\n            creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n        }\n    },\n    \n    guardian: function(creep) {\n        // Supreme defensive specialist\n        const enemies = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (enemies.length > 0) {\n            // Defend key structures\n            const spawns = creep.room.find(FIND_MY_SPAWNS);\n            const towers = creep.room.find(FIND_MY_STRUCTURES, {filter: {structureType: STRUCTURE_TOWER}});\n            \n            let defendTarget = null;\n            if (spawns.length > 0) {\n                defendTarget = creep.pos.findClosestByRange(spawns);\n            } else if (towers.length > 0) {\n                defendTarget = creep.pos.findClosestByRange(towers);\n            }\n            \n            if (defendTarget) {\n                // Move to defend and engage enemies\n                const enemy = creep.pos.findClosestByRange(enemies);\n                if (enemy && creep.pos.getRangeTo(enemy) <= 3) {\n                    if (creep.attack(enemy) === ERR_NOT_IN_RANGE) {\n                        creep.moveTo(enemy);\n                    }\n                } else {\n                    creep.moveTo(defendTarget);\n                }\n            } else {\n                // Engage nearest enemy\n                const enemy = creep.pos.findClosestByRange(enemies);\n                if (creep.attack(enemy) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(enemy);\n                }\n            }\n        } else {\n            // Patrol defensive positions\n            const spawns = creep.room.find(FIND_MY_SPAWNS);\n            if (spawns.length > 0) {\n                const spawn = spawns[0];\n                creep.moveTo(new RoomPosition(spawn.pos.x + Math.random() * 6 - 3, spawn.pos.y + Math.random() * 6 - 3, spawn.room.name));\n            }\n        }\n    },\n    \n    assassin: function(creep) {\n        // Supreme high-value target elimination\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#aa0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if needed\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        // Target priority enemies\n        const enemies = creep.room.find(FIND_HOSTILE_CREEPS);\n        \n        // Priority 1: Enemy healers\n        const enemyHealers = enemies.filter(e => e.getActiveBodyparts(HEAL) > 0);\n        if (enemyHealers.length > 0) {\n            const target = creep.pos.findClosestByRange(enemyHealers);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#aa0000'}});\n            }\n            return;\n        }\n        \n        // Priority 2: Enemy commanders (named creeps)\n        const enemyCommanders = enemies.filter(e => e.name && e.name.includes('commander'));\n        if (enemyCommanders.length > 0) {\n            const target = creep.pos.findClosestByRange(enemyCommanders);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#aa0000'}});\n            }\n            return;\n        }\n        \n        // Priority 3: Any enemy\n        supremeCombat.engageEnemy(creep);\n    },\n    \n    kamikaze: function(creep) {\n        // Supreme suicide assault\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Find highest value target with no regard for survival\n        const targets = [\n            ...creep.room.find(FIND_HOSTILE_SPAWNS),\n            ...creep.room.find(FIND_HOSTILE_STRUCTURES, {filter: {structureType: STRUCTURE_TOWER}}),\n            ...creep.room.find(FIND_HOSTILE_STRUCTURES, {filter: {structureType: STRUCTURE_EXTENSION}}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS, {filter: c => c.getActiveBodyparts(HEAL) > 0}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS, {filter: c => c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS)\n        ];\n        \n        if (targets.length > 0) {\n            const target = creep.pos.findClosestByRange(targets);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            const targetType = target.structureType || 'CREEP';\n            console.log(`üíÄüåã KAMIKAZE ${creep.name} ANNIHILATING ${targetType}! ACCEPT DEATH!`);\n        } else {\n            // No targets? Move to center and wait for death\n            creep.moveTo(new RoomPosition(25, 25, creep.room.name));\n            console.log(`üíÄ KAMIKAZE ${creep.name} AWAITING DEATH IN ENEMY TERRITORY`);\n        }\n    },\n    \n    destroyer: function(creep) {\n        // Supreme heavy assault\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if needed\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        // Target enemy structures first\n        const enemySpawns = creep.room.find(FIND_HOSTILE_SPAWNS);\n        if (enemySpawns.length > 0) {\n            const target = creep.pos.findClosestByRange(enemySpawns);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üè¥‚Äç‚ò†Ô∏è DESTROYER ${creep.name} DEMOLISHING ENEMY SPAWN!`);\n            return;\n        }\n        \n        const enemyTowers = creep.room.find(FIND_HOSTILE_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        });\n        if (enemyTowers.length > 0) {\n            const target = creep.pos.findClosestByRange(enemyTowers);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üèóÔ∏è DESTROYER ${creep.name} DESTROYING ENEMY TOWER!`);\n            return;\n        }\n        \n        // Mass attack enemy creeps\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`‚öîÔ∏è DESTROYER ${creep.name} OBLITERATING ENEMY CREEPS!`);\n        }\n    },\n    \n    siege: function(creep) {\n        // Supreme siege warfare\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if needed\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            \n            if (creep.rangedAttack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                // Use mass attack for maximum destruction\n                if (hostiles.length > 2 && creep.pos.getRangeTo(target) <= 3) {\n                    creep.rangedMassAttack();\n                    console.log(`üí• SIEGE ${creep.name} EXECUTING MASS ATTACK!`);\n                } else {\n                    creep.rangedAttack(target);\n                }\n            }\n        } else if (creep.memory.mode === 'assault') {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n        }\n    },\n    \n    medic: function(creep) {\n        // Supreme combat medic\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#00ff00'}});\n            return;\n        }\n        \n        // Heal critically wounded military allies first\n        const criticalAllies = creep.room.find(FIND_MY_CREEPS, {\n            filter: ally => (ally.memory.role === 'warrior' || ally.memory.role === 'archer' || \n                           ally.memory.role === 'destroyer' || ally.memory.role === 'siege' || \n                           ally.memory.role === 'annihilator' || ally.memory.role === 'commander') && \n                           ally.hits < ally.hitsMax * 0.3\n        });\n        \n        if (criticalAllies.length > 0) {\n            const target = creep.pos.findClosestByRange(criticalAllies);\n            if (creep.heal(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n            return;\n        }\n        \n        // Heal wounded military allies\n        const militaryAllies = creep.room.find(FIND_MY_CREEPS, {\n            filter: ally => (ally.memory.role === 'warrior' || ally.memory.role === 'archer' || \n                           ally.memory.role === 'destroyer' || ally.memory.role === 'siege' || \n                           ally.memory.role === 'kamikaze' || ally.memory.role === 'assassin' ||\n                           ally.memory.role === 'annihilator' || ally.memory.role === 'commander') && \n                           ally.hits < ally.hitsMax\n        });\n        \n        if (militaryAllies.length > 0) {\n            const target = creep.pos.findClosestByRange(militaryAllies);\n            if (creep.heal(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n            return;\n        }\n        \n        // Heal any damaged ally\n        const damagedAlly = creep.pos.findClosestByRange(FIND_MY_CREEPS, {\n            filter: ally => ally.hits < ally.hitsMax\n        });\n        \n        if (damagedAlly) {\n            if (creep.heal(damagedAlly) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(damagedAlly, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n            return;\n        }\n        \n        // Follow assault forces if no one needs healing\n        const assaultForces = creep.room.find(FIND_MY_CREEPS, {\n            filter: ally => ['warrior', 'archer', 'destroyer', 'siege', 'annihilator'].includes(ally.memory.role)\n        });\n        \n        if (assaultForces.length > 0) {\n            const target = creep.pos.findClosestByRange(assaultForces);\n            if (creep.pos.getRangeTo(target) > 2) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n        }\n    },\n    \n    annihilator: function(creep) {\n        // Supreme ultimate war machine\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Execute tactical retreat if needed\n        if (supremeMilitary.executeTacticalRetreat(creep)) return;\n        \n        // Multi-role combat: Attack with melee, ranged, and heal self\n        const enemySpawn = creep.pos.findClosestByPath(FIND_HOSTILE_SPAWNS);\n        if (enemySpawn) {\n            if (creep.attack(enemySpawn) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemySpawn, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                // Use ranged attack if in range\n                if (creep.pos.getRangeTo(enemySpawn) <= 3) {\n                    creep.rangedAttack(enemySpawn);\n                }\n                // Heal self if damaged\n                if (creep.hits < creep.hitsMax) {\n                    creep.heal(creep);\n                }\n            }\n            console.log(`üåã ANNIHILATOR ${creep.name} DESTROYING ENEMY SPAWN WITH ULTIMATE FORCE!`);\n            return;\n        }\n        \n        // Target enemy towers\n        const enemyTower = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        });\n        if (enemyTower) {\n            if (creep.attack(enemyTower) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemyTower, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                if (creep.pos.getRangeTo(enemyTower) <= 3) {\n                    creep.rangedAttack(enemyTower);\n                }\n                if (creep.hits < creep.hitsMax) {\n                    creep.heal(creep);\n                }\n            }\n            console.log(`üèóÔ∏è ANNIHILATOR ${creep.name} DEMOLISHING ENEMY TOWER WITH ULTIMATE FORCE!`);\n            return;\n        }\n        \n        // Mass attack enemy creeps\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                // Use ranged mass attack if multiple enemies nearby\n                if (hostiles.length > 2 && creep.pos.getRangeTo(target) <= 3) {\n                    creep.rangedMassAttack();\n                } else {\n                    creep.rangedAttack(target);\n                }\n                // Heal self while fighting\n                if (creep.hits < creep.hitsMax) {\n                    creep.heal(creep);\n                }\n            }\n            console.log(`‚öîÔ∏è ANNIHILATOR ${creep.name} OBLITERATING ENEMY CREEPS WITH ULTIMATE FORCE!`);\n            return;\n        }\n        \n        // Heal self if no enemies and damaged\n        if (creep.hits < creep.hitsMax) {\n            creep.heal(creep);\n        }\n    },\n    \n    commander: function(creep) {\n        // Supreme battlefield command and control\n        if (creep.memory.mode === 'assault' && creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#gold'}});\n            return;\n        }\n        \n        // Command and coordinate nearby forces\n        const nearbyAllies = creep.room.find(FIND_MY_CREEPS, {\n            filter: ally => ally.pos.getRangeTo(creep) <= 5 && ally.memory.role !== 'commander'\n        });\n        \n        if (nearbyAllies.length > 0) {\n            // Boost ally performance through coordination\n            nearbyAllies.forEach(ally => {\n                // Share tactical information\n                if (!ally.memory.commanderBonus) {\n                    ally.memory.commanderBonus = true;\n                    console.log(`üëë Commander ${creep.name} boosting ${ally.name}`);\n                }\n            });\n        }\n        \n        // Engage in combat with enhanced capabilities\n        const enemies = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (enemies.length > 0) {\n            const target = creep.pos.findClosestByRange(enemies);\n            \n            // Multi-attack: melee + ranged\n            if (creep.pos.getRangeTo(target) <= 1) {\n                creep.attack(target);\n            } else if (creep.pos.getRangeTo(target) <= 3) {\n                creep.rangedAttack(target);\n            } else {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#gold'}});\n            }\n            \n            // Self-heal while fighting\n            if (creep.hits < creep.hitsMax) {\n                creep.heal(creep);\n            }\n            \n            console.log(`üëë COMMANDER ${creep.name} LEADING THE ASSAULT!`);\n        } else if (creep.memory.mode === 'assault') {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#gold'}});\n        }\n    }\n};\n\n// SUPREME spawn management - Elite production facility\nconst supremeSpawn = {\n    spawnCreep: function(spawn, role) {\n        const roleConfig = supremeRoles[role];\n        if (!roleConfig) return null;\n        \n        const body = roleConfig.body;\n        const name = `${role}_${Game.time}_${Math.floor(Math.random() * 10000)}`;\n        \n        const result = spawn.spawnCreep(body, name, {\n            memory: {\n                role: role,\n                born: Game.time,\n                homeRoom: spawn.room.name,\n                veteran: false,\n                commanderBonus: false\n            }\n        });\n        \n        if (result === OK) {\n            console.log(`üÜï SUPREME Spawned ${role}: ${name}`);\n            return name;\n        }\n        \n        return null;\n    },\n    \n    manageSupremeSpawning: function(spawn) {\n        if (spawn.spawning) return;\n        \n        const room = spawn.room;\n        const currentCreeps = Object.keys(Game.creeps);\n        \n        // Advanced creep counting with room awareness\n        const roomCreeps = {};\n        const totalCreeps = {};\n        \n        currentCreeps.forEach(name => {\n            const creep = Game.creeps[name];\n            if (creep.memory.role) {\n                totalCreeps[creep.memory.role] = (totalCreeps[creep.memory.role] || 0) + 1;\n                if (creep.room.name === room.name) {\n                    roomCreeps[creep.memory.role] = (roomCreeps[creep.memory.role] || 0) + 1;\n                }\n            }\n        });\n        \n        // Determine economic status\n        const energyAvailable = room.energyAvailable;\n        const energyCapacity = room.energyCapacityAvailable;\n        const energyRatio = energyAvailable / energyCapacity;\n        \n        if (energyRatio < 0.2) {\n            dominationState.economicPhase = 'critical';\n        } else if (energyRatio < 0.5) {\n            dominationState.economicPhase = 'developing';\n        } else {\n            dominationState.economicPhase = 'strong';\n        }\n        \n        // Determine military status based on threat level\n        const recentReports = supremeIntelligence.getRecentReports(100);\n        const totalThreat = recentReports.reduce((sum, report) => sum + report.threatLevel, 0);\n        \n        if (totalThreat > 50) {\n            dominationState.militaryPhase = 'total_annihilation';\n        } else if (totalThreat > 20) {\n            dominationState.militaryPhase = 'active_defense';\n        } else if (recentReports.length > 0) {\n            dominationState.militaryPhase = 'threat_detected';\n        } else {\n            dominationState.militaryPhase = 'surveillance';\n        }\n        \n        // SUPREME spawning strategy based on battlefield conditions\n        if (dominationState.militaryPhase === 'total_annihilation') {\n            // Maximum military production\n            if (roomCreeps.annihilator < supremeRoles.annihilator.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'annihilator');\n                return;\n            }\n            if (roomCreeps.commander < supremeRoles.commander.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'commander');\n                return;\n            }\n            if (roomCreeps.destroyer < supremeRoles.destroyer.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'destroyer');\n                return;\n            }\n            if (roomCreeps.siege < supremeRoles.siege.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'siege');\n                return;\n            }\n            if (roomCreeps.kamikaze < supremeRoles.kamikaze.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'kamikaze');\n                return;\n            }\n            if (roomCreeps.medic < supremeRoles.medic.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'medic');\n                return;\n            }\n        }\n        \n        if (dominationState.militaryPhase === 'active_defense') {\n            // Defensive military buildup\n            if (roomCreeps.warrior < 4) {\n                supremeSpawn.spawnCreep(spawn, 'warrior');\n                return;\n            }\n            if (roomCreeps.archer < 4) {\n                supremeSpawn.spawnCreep(spawn, 'archer');\n                return;\n            }\n            if (roomCreeps.guardian < 3) {\n                supremeSpawn.spawnCreep(spawn, 'guardian');\n                return;\n            }\n            if (roomCreeps.medic < 2) {\n                supremeSpawn.spawnCreep(spawn, 'medic');\n                return;\n            }\n        }\n        \n        if (dominationState.militaryPhase === 'threat_detected') {\n            // Moderate military production\n            if (roomCreeps.warrior < 3) {\n                supremeSpawn.spawnCreep(spawn, 'warrior');\n                return;\n            }\n            if (roomCreeps.archer < 2) {\n                supremeSpawn.spawnCreep(spawn, 'archer');\n                return;\n            }\n            if (roomCreeps.scout < 2) {\n                supremeSpawn.spawnCreep(spawn, 'scout');\n                return;\n            }\n        }\n        \n        // Economic production\n        if (dominationState.economicPhase === 'critical') {\n            // Emergency economic mode\n            if (roomCreeps.harvester < supremeRoles.harvester.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'harvester');\n                return;\n            }\n            if (roomCreeps.transporter < supremeRoles.transporter.emergencyCount) {\n                supremeSpawn.spawnCreep(spawn, 'transporter');\n                return;\n            }\n        } else {\n            // Normal economic production\n            for (const role in supremeRoles) {\n                const roleConfig = supremeRoles[role];\n                const currentCount = roomCreeps[role] || 0;\n                \n                let maxCount = roleConfig.maxCount;\n                if (dominationState.economicPhase === 'developing') {\n                    maxCount = Math.ceil(roleConfig.maxCount * 0.7);\n                } else if (dominationState.economicPhase === 'critical') {\n                    maxCount = roleConfig.emergencyCount;\n                }\n                \n                if (currentCount < maxCount && roleConfig.economic) {\n                    if (supremeSpawn.spawnCreep(spawn, role)) {\n                        return;\n                    }\n                }\n            }\n        }\n        \n        // Military production (normal mode)\n        for (const role in supremeRoles) {\n            const roleConfig = supremeRoles[role];\n            const currentCount = roomCreeps[role] || 0;\n            \n            if (currentCount < roleConfig.maxCount && roleConfig.military) {\n                if (supremeSpawn.spawnCreep(spawn, role)) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n// Main SUPREME loop - Absolute battlefield dominance\nmodule.exports.loop = function() {\n    // Update domination state\n    dominationState.currentTick = Game.time;\n    \n    // Clear dead creeps from memory\n    for (const name in Memory.creeps) {\n        if (!Game.creeps[name]) {\n            delete Memory.creeps[name];\n            console.log(`üíÄ SUPREME Cleared dead creep: ${name}`);\n        }\n    }\n    \n    // Get current room\n    const room = Game.rooms[dominationState.roomName];\n    if (!room) {\n        console.log(`‚ùå SUPREME Room ${dominationState.roomName} not found!`);\n        return;\n    }\n    \n    // SUPREME BATTLEFIELD ANALYSIS\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\n    const enemyStructures = room.find(FIND_HOSTILE_STRUCTURES);\n    const enemySpawns = room.find(FIND_HOSTILE_SPAWNS);\n    const enemyTowers = room.find(FIND_HOSTILE_STRUCTURES, {\n        filter: { structureType: STRUCTURE_TOWER }\n    });\n    \n    // Update domination mode based on battlefield assessment\n    if (hostiles.length > 0 || enemyStructures.length > 0) {\n        dominationState.lastEnemyContact = Game.time;\n        \n        // Calculate threat level with supreme precision\n        const dangerousEnemies = hostiles.filter(e => \n            e.getActiveBodyparts(ATTACK) > 0 || e.getActiveBodyparts(RANGED_ATTACK) > 0\n        ).length;\n        \n        const totalEnemyParts = hostiles.reduce((sum, enemy) => sum + enemy.body.length, 0);\n        const hasEnemySpawns = enemySpawns.length > 0;\n        const hasEnemyTowers = enemyTowers.length > 0;\n        \n        // SUPREME threat assessment\n        if (hasEnemySpawns || hasEnemyTowers || dangerousEnemies >= 8 || totalEnemyParts >= 50) {\n            dominationState.mode = DOMINATION_MODE.ANNIHILATION;\n            dominationState.militaryPhase = 'total_annihilation';\n            if (!dominationState.dominationDeclared) {\n                dominationState.dominationDeclared = true;\n                console.log(`üî•üî•üî• DOMINATION DECLARED - NO MERCY FOR ENEMIES! üî•üî•üî•`);\n            }\n        } else if (dangerousEnemies >= 5 || totalEnemyParts >= 25) {\n            dominationState.mode = DOMINATION_MODE.TOTAL_WAR;\n            dominationState.militaryPhase = 'total_war';\n        } else if (dangerousEnemies >= 3) {\n            dominationState.mode = DOMINATION_MODE.OFFENSIVE_OPERATIONS;\n            dominationState.militaryPhase = 'offensive_operations';\n        } else if (dangerousEnemies > 0) {\n            dominationState.mode = DOMINATION_MODE.ACTIVE_DEFENSE;\n            dominationState.militaryPhase = 'active_defense';\n        } else {\n            dominationState.mode = DOMINATION_MODE.THREAT_DETECTED;\n            dominationState.militaryPhase = 'threat_detected';\n        }\n    } else {\n        // Gradually decrease alert level\n        const timeSinceContact = Game.time - dominationState.lastEnemyContact;\n        if (timeSinceContact > 200) {\n            dominationState.mode = DOMINATION_MODE.SURVEILLANCE;\n            dominationState.militaryPhase = 'surveillance';\n        } else if (timeSinceContact > 100) {\n            dominationState.mode = DOMINATION_MODE.THREAT_DETECTED;\n            dominationState.militaryPhase = 'threat_detected';\n        } else if (timeSinceContact > 50) {\n            dominationState.mode = DOMINATION_MODE.ACTIVE_DEFENSE;\n            dominationState.militaryPhase = 'active_defense';\n        }\n    }\n    \n    // SUPREME CONSTRUCTION - Build fortress of domination\n    if (Game.time % 10 === 0) {\n        supremeDefense.buildSupremeFortress(room);\n        supremeDefense.buildSupremeTowers(room);\n        supremeDefense.buildSupremeExtensions(room);\n    }\n    \n    // SUPREME TOWER OPERATIONS - Annihilate all threats\n    const towerResults = supremeDefense.activateSupremeTowers(room);\n    \n    // SUPREME SPAWNING - Elite production facility\n    const spawns = room.find(FIND_MY_SPAWNS);\n    spawns.forEach(spawn => {\n        supremeSpawn.manageSupremeSpawning(spawn);\n    });\n    \n    // SUPREME ROLE EXECUTION - Elite battlefield performance\n    for (const name in Game.creeps) {\n        const creep = Game.creeps[name];\n        if (creep.spawning) continue;\n        \n        const role = creep.memory.role;\n        if (supremeExecution[role]) {\n            try {\n                supremeExecution[role](creep);\n            } catch (error) {\n                console.log(`‚ùå SUPREME Error in ${role} ${name}: ${error}`);\n            }\n        }\n    }\n    \n    // SUPREME ATTACK OPERATIONS - Total enemy annihilation\n    if (Game.time % 25 === 0 && dominationState.mode >= DOMINATION_MODE.OFFENSIVE_OPERATIONS) {\n        const priorityTarget = supremeIntelligence.selectPriorityTarget();\n        if (priorityTarget) {\n            supremeMilitary.launchSupremeAttack(priorityTarget);\n        }\n    }\n    \n    // CONTINUOUS SUPREME RECONNAISSANCE - Maintain intelligence superiority\n    if (Game.time % 40 === 0) {\n        const scouts = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return (creep.memory.role === 'scout' || creep.memory.role === 'infiltrator') && \n                   creep.room.name === dominationState.roomName;\n        });\n        \n        if (scouts.length > 0) {\n            const scoutName = scouts[Math.floor(Math.random() * scouts.length)];\n            const scout = Game.creeps[scoutName];\n            if (scout) {\n                supremeExecution.scout(scout);\n            }\n        }\n    }\n    \n    // SUPREME DOMINATION ESCALATION - Expand operations if no enemies found\n    if (Game.time % 600 === 0 && dominationState.mode === DOMINATION_MODE.SURVEILLANCE && !dominationState.supremeCommander) {\n        console.log(`üåç SUPREME Expanding domination operations...`);\n        // Widen search parameters\n        const expansionRooms = ['W5N1', 'W5N2', 'W5N3', 'W6N1', 'W6N2', 'W7N1', 'W7N2', 'W8N1', 'W9N1', 'W10N1'];\n        // Scouts will pick these up in their random selection\n    }\n    \n    // SUPREME STATUS REPORT - Display absolute dominance\n    if (Game.time % 10 === 0) {\n        const modeNames = ['PEACETIME', 'SURVEILLANCE', 'THREAT_DETECTED', 'ACTIVE_DEFENSE', \n                          'OFFENSIVE_OPERATIONS', 'TOTAL_WAR', 'ANNIHILATION', 'DOMINATION'];\n        \n        const recentReports = supremeIntelligence.getRecentReports(100);\n        const totalThreat = recentReports.reduce((sum, report) => sum + report.threatLevel, 0);\n        \n        const militaryForces = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return supremeRoles[creep.memory.role] && supremeRoles[creep.memory.role].military && \n                   creep.room.name === dominationState.roomName;\n        }).length;\n        \n        const economicForces = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return supremeRoles[creep.memory.role] && supremeRoles[creep.memory.role].economic && \n                   creep.room.name === dominationState.roomName;\n        }).length;\n        \n        console.log(`üèÜ SUPREME AI: ${modeNames[dominationState.mode]} | Military: ${militaryForces} | Economic: ${economicForces} | Energy: ${room.energyAvailable}/${room.energyCapacityAvailable} | Threat: ${totalThreat} | Enemies: ${hostiles.length}`);\n        \n        if (dominationState.mode === DOMINATION_MODE.ANNIHILATION) {\n            console.log(`üî•üî•üî• TOTAL ANNIHILATION MODE - ENEMIES WILL BE ERADICATED! üî•üî•üî•`);\n        }\n        \n        if (dominationState.dominationDeclared) {\n            console.log(`üëë SUPREME DOMINATION ACTIVE - ALL WILL KNEEL BEFORE YOUR POWER! üëë`);\n        }\n    }\n};"}}