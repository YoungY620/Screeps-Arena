{"branch":"default","modules":{"main":"// üèÜ SCREEPS ULTIMATE PvP DOMINATION AI v3.0 üèÜ\n// ULTRA AGGRESSIVE EDITION - Maximum destruction, minimum mercy\n\nconst DEFENSE_MODE = {\n    PEACETIME: 0,\n    ALERT: 1,\n    WAR: 2,\n    EMERGENCY: 3,\n    TOTAL_WAR: 4\n};\n\nlet gameState = {\n    defenseMode: DEFENSE_MODE.PEACETIME,\n    lastEnemySeen: 0,\n    currentTick: 0,\n    roomName: 'W1N3',\n    spawnPos: {x: 25, y: 25},\n    enemies: [],\n    allies: [],\n    enemyRooms: new Set(),\n    attackTargets: [],\n    lastAttackTime: 0,\n    attackWaveSize: 0,\n    maxAttackWave: 6\n};\n\n// ULTRA military unit designs - Maximum damage, maximum speed\nconst militaryBodies = {\n    scout: [MOVE, MOVE, MOVE, MOVE, MOVE], // Ultra fast\n    \n    warrior: [TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    archer: [TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    healer: [TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE],\n    \n    destroyer: [TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    siege: [TOUGH, TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE],\n    \n    assassin: [MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK], // Lightning fast killer\n    \n    kamikaze: [MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK] // Pure offense\n};\n\n// Enhanced role system with ULTRA priorities\nconst roles = {\n    harvester: {\n        body: [WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 8,\n        priority: 1,\n        emergencyCount: 3\n    },\n    \n    upgrader: {\n        body: [WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 6,\n        priority: 2,\n        emergencyCount: 2\n    },\n    \n    builder: {\n        body: [WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 4,\n        priority: 3,\n        emergencyCount: 1\n    },\n    \n    repairer: {\n        body: [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\n        maxCount: 2,\n        priority: 4,\n        emergencyCount: 1\n    },\n    \n    scout: {\n        body: militaryBodies.scout,\n        maxCount: 3,\n        priority: 5,\n        emergencyCount: 1\n    },\n    \n    warrior: {\n        body: militaryBodies.warrior,\n        maxCount: 4,\n        priority: 6,\n        emergencyCount: 2\n    },\n    \n    archer: {\n        body: militaryBodies.archer,\n        maxCount: 4,\n        priority: 7,\n        emergencyCount: 2\n    },\n    \n    healer: {\n        body: militaryBodies.healer,\n        maxCount: 3,\n        priority: 8,\n        emergencyCount: 1\n    },\n    \n    attacker: {\n        body: militaryBodies.destroyer,\n        maxCount: 6,\n        priority: 9,\n        emergencyCount: 3\n    },\n    \n    kamikaze: {\n        body: militaryBodies.kamikaze,\n        maxCount: 4,\n        priority: 10,\n        emergencyCount: 2\n    }\n};\n\n// ULTRA defense system - Impenetrable fortress\nconst defense = {\n    buildFortress: function(room) {\n        const spawn = Game.spawns.Spawn1;\n        if (!spawn) return;\n        \n        // Build MASSIVE walls around spawn\n        const wallPositions = [];\n        for (let x = spawn.pos.x - 4; x <= spawn.pos.x + 4; x++) {\n            for (let y = spawn.pos.y - 4; y <= spawn.pos.y + 4; y++) {\n                if (Math.abs(x - spawn.pos.x) >= 3 || Math.abs(y - spawn.pos.y) >= 3) {\n                    wallPositions.push({x, y});\n                }\n            }\n        }\n        \n        wallPositions.forEach(pos => {\n            const structures = room.lookForAt(LOOK_STRUCTURES, pos.x, pos.y);\n            const hasWall = structures.some(s => s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART);\n            \n            if (!hasWall) {\n                if (room.createConstructionSite(pos.x, pos.y, STRUCTURE_RAMPART) === OK) {\n                    console.log(`üè∞ ULTRA Fortress rampart at ${pos.x},${pos.y}`);\n                }\n            }\n        });\n    },\n    \n    buildTowers: function(room) {\n        const towerCount = room.find(FIND_MY_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        }).length;\n        \n        if (towerCount < 6) {\n            const towerPositions = [\n                {x: gameState.spawnPos.x - 5, y: gameState.spawnPos.y - 5},\n                {x: gameState.spawnPos.x + 5, y: gameState.spawnPos.y - 5},\n                {x: gameState.spawnPos.x - 5, y: gameState.spawnPos.y + 5},\n                {x: gameState.spawnPos.x + 5, y: gameState.spawnPos.y + 5},\n                {x: gameState.spawnPos.x, y: gameState.spawnPos.y - 7},\n                {x: gameState.spawnPos.x, y: gameState.spawnPos.y + 7}\n            ];\n            \n            towerPositions.forEach(pos => {\n                if (room.createConstructionSite(pos.x, pos.y, STRUCTURE_TOWER) === OK) {\n                    console.log(`üèóÔ∏è ULTRA Tower construction at ${pos.x},${pos.y}`);\n                }\n            });\n        }\n    },\n    \n    buildExtensions: function(room) {\n        const extensionCount = room.find(FIND_MY_STRUCTURES, {\n            filter: { structureType: STRUCTURE_EXTENSION }\n        }).length;\n        \n        if (extensionCount < 50) {\n            const positions = [];\n            for (let x = gameState.spawnPos.x - 10; x <= gameState.spawnPos.x + 10; x++) {\n                for (let y = gameState.spawnPos.y - 10; y <= gameState.spawnPos.y + 10; y++) {\n                    if (Math.abs(x - gameState.spawnPos.x) + Math.abs(y - gameState.spawnPos.y) > 4) {\n                        positions.push({x, y});\n                    }\n                }\n            }\n            \n            positions.forEach(pos => {\n                if (room.createConstructionSite(pos.x, pos.y, STRUCTURE_EXTENSION) === OK) {\n                    console.log(`üîã ULTRA Extension at ${pos.x},${pos.y}`);\n                }\n            });\n        }\n    },\n    \n    activateTowers: function(room) {\n        const towers = room.find(FIND_MY_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        });\n        \n        let enemiesEngaged = 0;\n        \n        towers.forEach(tower => {\n            // ULTRA PRIORITY: Kill enemy healers first\n            const hostileHealers = tower.room.find(FIND_HOSTILE_CREEPS, {\n                filter: hostile => hostile.getActiveBodyparts(HEAL) > 0\n            });\n            \n            if (hostileHealers.length > 0) {\n                const target = tower.pos.findClosestByRange(hostileHealers);\n                if (target) {\n                    tower.attack(target);\n                    console.log(`üí• ULTRA Tower SNIPING healer!`);\n                    enemiesEngaged++;\n                    return;\n                }\n            }\n            \n            // Then kill attackers\n            const hostileAttackers = tower.room.find(FIND_HOSTILE_CREEPS, {\n                filter: hostile => {\n                    return hostile.getActiveBodyparts(ATTACK) > 0 || hostile.getActiveBodyparts(RANGED_ATTACK) > 0;\n                }\n            });\n            \n            if (hostileAttackers.length > 0) {\n                const target = tower.pos.findClosestByRange(hostileAttackers);\n                if (target) {\n                    tower.attack(target);\n                    console.log(`‚öîÔ∏è ULTRA Tower engaging hostile attacker!`);\n                    enemiesEngaged++;\n                    return;\n                }\n            }\n            \n            // Finally attack any hostile\n            const closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n            if (closestHostile) {\n                tower.attack(closestHostile);\n                console.log(`‚öîÔ∏è ULTRA Tower attacking hostile`);\n                enemiesEngaged++;\n                return;\n            }\n            \n            // Heal damaged allies\n            const damagedAlly = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n                filter: creep => creep.hits < creep.hitsMax\n            });\n            \n            if (damagedAlly) {\n                tower.heal(damagedAlly);\n                console.log(`üíö ULTRA Tower healing ally`);\n            }\n        });\n        \n        return enemiesEngaged;\n    }\n};\n\n// ULTRA military tactics\nconst military = {\n    scoutEnemy: function(creep) {\n        const enemyRooms = ['W1N1', 'W1N2', 'W1N4', 'W1N5', 'W2N1', 'W2N2', 'W2N3', 'W0N1', 'W0N2', 'W0N3'];\n        const targetRoom = enemyRooms[Math.floor(Math.random() * enemyRooms.length)];\n        \n        if (creep.room.name !== targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, targetRoom), {visualizePathStyle: {stroke: '#00ff00'}});\n            return;\n        }\n        \n        // Scout for enemies\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        const enemyStructures = creep.room.find(FIND_HOSTILE_STRUCTURES);\n        \n        if (hostiles.length > 0 || enemyStructures.length > 0) {\n            gameState.enemyRooms.add(creep.room.name);\n            console.log(`üéØ ULTRA SCOUT Found enemy in ${creep.room.name}!`);\n            \n            // Prioritize enemy spawn locations\n            const enemySpawns = enemyStructures.filter(s => s.structureType === STRUCTURE_SPAWN);\n            if (enemySpawns.length > 0) {\n                gameState.attackTargets.push({\n                    room: creep.room.name,\n                    type: 'spawn',\n                    pos: enemySpawns[0].pos,\n                    priority: 1\n                });\n            }\n        }\n        \n        // Keep moving to avoid being hit\n        creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n    },\n    \n    launchUltraAttack: function(targetRoom) {\n        console.log(`üöÄ LAUNCHING ULTRA ATTACK ON ${targetRoom}!`);\n        \n        // Get current attack forces\n        const attackers = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return (creep.memory.role === 'attacker' || creep.memory.role === 'kamikaze') && \n                   creep.room.name === gameState.roomName;\n        }).length;\n        \n        const healers = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return creep.memory.role === 'healer' && creep.room.name === gameState.roomName;\n        }).length;\n        \n        console.log(`üìä Current forces: ${attackers} attackers, ${healers} healers`);\n        \n        // Launch coordinated attack\n        if (attackers >= 2) {\n            // Move existing forces to attack\n            Object.keys(Game.creeps).forEach(name => {\n                const creep = Game.creeps[name];\n                if ((creep.memory.role === 'attacker' || creep.memory.role === 'kamikaze') && creep.room.name === gameState.roomName) {\n                    creep.memory.targetRoom = targetRoom;\n                    creep.memory.mode = 'attack';\n                    console.log(`üéØ ${name} ordered to attack ${targetRoom}`);\n                }\n                if (creep.memory.role === 'healer' && creep.room.name === gameState.roomName) {\n                    creep.memory.targetRoom = targetRoom;\n                    creep.memory.mode = 'support';\n                    console.log(`üíö ${name} ordered to support attack on ${targetRoom}`);\n                }\n            });\n            \n            gameState.lastAttackTime = Game.time;\n            gameState.attackWaveSize = attackers;\n        }\n    }\n};\n\n// Role execution functions\nconst roleFunctions = {\n    harvester: function(creep) {\n        if (creep.store.getFreeCapacity() > 0) {\n            const sources = creep.room.find(FIND_SOURCES);\n            if (creep.harvest(sources[0]) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }\n        } else {\n            const targets = creep.room.find(FIND_STRUCTURES, {\n                filter: (structure) => {\n                    return (structure.structureType === STRUCTURE_EXTENSION ||\n                            structure.structureType === STRUCTURE_SPAWN ||\n                            structure.structureType === STRUCTURE_TOWER) &&\n                            structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                }\n            });\n            if (targets.length > 0) {\n                if (creep.transfer(targets[0], RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        }\n    },\n    \n    upgrader: function(creep) {\n        if (creep.store[RESOURCE_ENERGY] === 0) {\n            const sources = creep.room.find(FIND_SOURCES);\n            if (creep.harvest(sources[0]) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }\n        } else {\n            if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#ffffff'}});\n            }\n        }\n    },\n    \n    builder: function(creep) {\n        const targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n        if (targets.length) {\n            if (creep.store[RESOURCE_ENERGY] === 0) {\n                const sources = creep.room.find(FIND_SOURCES);\n                if (creep.harvest(sources[0]) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});\n                }\n            } else {\n                if (creep.build(targets[0]) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        } else {\n            // No construction sites, help as upgrader\n            roleFunctions.upgrader(creep);\n        }\n    },\n    \n    repairer: function(creep) {\n        const targets = creep.room.find(FIND_STRUCTURES, {\n            filter: object => object.hits < object.hitsMax && object.structureType !== STRUCTURE_WALL\n        });\n        \n        targets.sort((a, b) => a.hits - b.hits);\n        \n        if (targets.length > 0) {\n            if (creep.store[RESOURCE_ENERGY] === 0) {\n                const sources = creep.room.find(FIND_SOURCES);\n                if (creep.harvest(sources[0]) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});\n                }\n            } else {\n                if (creep.repair(targets[0]) === ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n            }\n        } else {\n            // Nothing to repair, help as builder\n            roleFunctions.builder(creep);\n        }\n    },\n    \n    scout: function(creep) {\n        military.scoutEnemy(creep);\n    },\n    \n    warrior: function(creep) {\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n        } else {\n            // Patrol around room\n            creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n        }\n    },\n    \n    archer: function(creep) {\n        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\n        if (hostiles.length > 0) {\n            const target = creep.pos.findClosestByRange(hostiles);\n            if (creep.rangedAttack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            } else {\n                // Mass attack if close to multiple enemies\n                creep.rangedMassAttack();\n            }\n        } else {\n            // Patrol\n            creep.moveTo(new RoomPosition(Math.random() * 40 + 10, Math.random() * 40 + 10, creep.room.name));\n        }\n    },\n    \n    healer: function(creep) {\n        // Heal damaged allies first\n        const damagedAlly = creep.pos.findClosestByRange(FIND_MY_CREEPS, {\n            filter: ally => ally.hits < ally.hitsMax\n        });\n        \n        if (damagedAlly) {\n            if (creep.heal(damagedAlly) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(damagedAlly, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n            return;\n        }\n        \n        // Follow military units if no one needs healing\n        const militaryUnits = creep.room.find(FIND_MY_CREEPS, {\n            filter: ally => ['warrior', 'archer', 'attacker', 'kamikaze'].includes(ally.memory.role)\n        });\n        \n        if (militaryUnits.length > 0) {\n            const target = creep.pos.findClosestByRange(militaryUnits);\n            if (creep.pos.getRangeTo(target) > 2) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#00ff00'}});\n            }\n        }\n    },\n    \n    attacker: function(creep) {\n        // ULTRA ATTACK MODE\n        if (creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Target enemy spawns first (HIGHEST PRIORITY)\n        const enemySpawn = creep.pos.findClosestByPath(FIND_HOSTILE_SPAWNS);\n        if (enemySpawn) {\n            if (creep.attack(enemySpawn) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemySpawn, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üíÄ ${creep.name} ATTACKING ENEMY SPAWN!`);\n            return;\n        }\n        \n        // Target enemy towers\n        const enemyTower = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n            filter: { structureType: STRUCTURE_TOWER }\n        });\n        if (enemyTower) {\n            if (creep.attack(enemyTower) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemyTower, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üèóÔ∏è ${creep.name} DESTROYING ENEMY TOWER!`);\n            return;\n        }\n        \n        // Target enemy extensions and containers\n        const enemyStructures = creep.room.find(FIND_HOSTILE_STRUCTURES, {\n            filter: s => s.structureType === STRUCTURE_EXTENSION || \n                        s.structureType === STRUCTURE_CONTAINER || \n                        s.structureType === STRUCTURE_STORAGE\n        });\n        if (enemyStructures.length > 0) {\n            const target = creep.pos.findClosestByRange(enemyStructures);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üî• ${creep.name} DESTROYING ENEMY STRUCTURES!`);\n            return;\n        }\n        \n        // Kill enemy creeps\n        const enemyCreep = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {\n            filter: hostile => hostile.getActiveBodyparts(ATTACK) > 0 || hostile.getActiveBodyparts(RANGED_ATTACK) > 0\n        });\n        if (enemyCreep) {\n            if (creep.attack(enemyCreep) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(enemyCreep, {visualizePathStyle: {stroke: '#aa0000'}});\n            }\n            console.log(`‚öîÔ∏è ${creep.name} KILLING ENEMY CREEPS!`);\n            return;\n        }\n        \n        // Attack anything else\n        const anyEnemy = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n        if (anyEnemy) {\n            if (creep.attack(anyEnemy) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(anyEnemy, {visualizePathStyle: {stroke: '#aa0000'}});\n            }\n            console.log(`üí• ${creep.name} ATTACKING ANY ENEMY!`);\n        }\n    },\n    \n    kamikaze: function(creep) {\n        // PURE SUICIDE ATTACKER - Maximum damage, no retreat\n        if (creep.memory.targetRoom && creep.room.name !== creep.memory.targetRoom) {\n            creep.moveTo(new RoomPosition(25, 25, creep.memory.targetRoom), {visualizePathStyle: {stroke: '#ff0000'}});\n            return;\n        }\n        \n        // Find highest value target\n        const targets = [\n            ...creep.room.find(FIND_HOSTILE_SPAWNS),\n            ...creep.room.find(FIND_HOSTILE_STRUCTURES, {filter: {structureType: STRUCTURE_TOWER}}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS, {filter: c => c.getActiveBodyparts(HEAL) > 0}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS, {filter: c => c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0}),\n            ...creep.room.find(FIND_HOSTILE_CREEPS)\n        ];\n        \n        if (targets.length > 0) {\n            const target = creep.pos.findClosestByRange(targets);\n            if (creep.attack(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});\n            }\n            console.log(`üíÄüí• KAMIKAZE ${creep.name} ATTACKING ${target.structureType || 'CREEP'}!`);\n        } else {\n            // No targets? Move to center and wait\n            creep.moveTo(new RoomPosition(25, 25, creep.room.name));\n        }\n    }\n};\n\n// Spawn management\nconst spawnManager = {\n    spawnCreep: function(spawn, role) {\n        const roleConfig = roles[role];\n        if (!roleConfig) return null;\n        \n        const body = roleConfig.body;\n        const name = `${role}_${Game.time}_${Math.floor(Math.random() * 1000)}`;\n        \n        const result = spawn.spawnCreep(body, name, {\n            memory: {\n                role: role,\n                born: Game.time,\n                homeRoom: spawn.room.name\n            }\n        });\n        \n        if (result === OK) {\n            console.log(`üÜï Spawned ${role}: ${name}`);\n            return name;\n        }\n        \n        return null;\n    },\n    \n    manageSpawning: function(spawn) {\n        if (spawn.spawning) return;\n        \n        const room = spawn.room;\n        const currentCreeps = Object.keys(Game.creeps);\n        \n        // Count creeps by role\n        const creepCounts = {};\n        currentCreeps.forEach(name => {\n            const creep = Game.creeps[name];\n            if (creep.memory.role) {\n                creepCounts[creep.memory.role] = (creepCounts[creep.memory.role] || 0) + 1;\n            }\n        });\n        \n        // ULTRA spawning strategy based on defense mode\n        if (gameState.defenseMode === DEFENSE_MODE.EMERGENCY || gameState.defenseMode === DEFENSE_MODE.TOTAL_WAR) {\n            // Emergency military production\n            if (creepCounts.warrior < 2) {\n                spawnManager.spawnCreep(spawn, 'warrior');\n                return;\n            }\n            if (creepCounts.kamikaze < 2) {\n                spawnManager.spawnCreep(spawn, 'kamikaze');\n                return;\n            }\n            if (creepCounts.archer < 2) {\n                spawnManager.spawnCreep(spawn, 'archer');\n                return;\n            }\n            if (creepCounts.healer < 1) {\n                spawnManager.spawnCreep(spawn, 'healer');\n                return;\n            }\n        }\n        \n        // Normal spawning priorities\n        for (const role in roles) {\n            const roleConfig = roles[role];\n            const currentCount = creepCounts[role] || 0;\n            \n            const maxCount = gameState.defenseMode >= DEFENSE_MODE.WAR ? \n                           roleConfig.emergencyCount : roleConfig.maxCount;\n            \n            if (currentCount < maxCount) {\n                spawnManager.spawnCreep(spawn, role);\n                return;\n            }\n        }\n    }\n};\n\n// Main game loop\nmodule.exports.loop = function() {\n    // Update game state\n    gameState.currentTick = Game.time;\n    \n    // Clear dead creeps from memory\n    for (const name in Memory.creeps) {\n        if (!Game.creeps[name]) {\n            delete Memory.creeps[name];\n            console.log(`üíÄ Cleared dead creep: ${name}`);\n        }\n    }\n    \n    // Get current room\n    const room = Game.rooms[gameState.roomName];\n    if (!room) {\n        console.log(`‚ùå Room ${gameState.roomName} not found!`);\n        return;\n    }\n    \n    // Find enemies in room\n    gameState.enemies = room.find(FIND_HOSTILE_CREEPS);\n    \n    // Update defense mode\n    if (gameState.enemies.length > 0) {\n        gameState.lastEnemySeen = Game.time;\n        \n        // Determine threat level\n        const dangerousEnemies = gameState.enemies.filter(e => \n            e.getActiveBodyparts(ATTACK) > 0 || e.getActiveBodyparts(RANGED_ATTACK) > 0\n        ).length;\n        \n        if (dangerousEnemies >= 3) {\n            gameState.defenseMode = DEFENSE_MODE.TOTAL_WAR;\n        } else if (dangerousEnemies > 0) {\n            gameState.defenseMode = DEFENSE_MODE.WAR;\n        } else {\n            gameState.defenseMode = DEFENSE_MODE.ALERT;\n        }\n    } else {\n        // Gradually decrease alert level\n        if (Game.time - gameState.lastEnemySeen > 100) {\n            gameState.defenseMode = DEFENSE_MODE.PEACETIME;\n        } else if (Game.time - gameState.lastEnemySeen > 50) {\n            gameState.defenseMode = DEFENSE_MODE.ALERT;\n        }\n    }\n    \n    // Build defenses\n    if (Game.time % 10 === 0) {\n        defense.buildFortress(room);\n        defense.buildTowers(room);\n        defense.buildExtensions(room);\n    }\n    \n    // Activate towers\n    const towersEngaged = defense.activateTowers(room);\n    \n    // Manage spawning\n    const spawn = Game.spawns.Spawn1;\n    if (spawn) {\n        spawnManager.manageSpawning(spawn);\n    }\n    \n    // Execute creep roles\n    for (const name in Game.creeps) {\n        const creep = Game.creeps[name];\n        if (creep.spawning) continue;\n        \n        const role = creep.memory.role;\n        if (roleFunctions[role]) {\n            try {\n                roleFunctions[role](creep);\n            } catch (error) {\n                console.log(`‚ùå Error in ${role} ${name}: ${error}`);\n            }\n        }\n    }\n    \n    // ULTRA ATTACK STRATEGY\n    if (Game.time % 50 === 0 && gameState.defenseMode >= DEFENSE_MODE.WAR) {\n        const targetRooms = Array.from(gameState.enemyRooms);\n        if (targetRooms.length > 0) {\n            // Pick strongest enemy room\n            const targetRoom = targetRooms[0];\n            military.launchUltraAttack(targetRoom);\n        }\n    }\n    \n    // Launch periodic attacks even without scouting\n    if (Game.time % 200 === 0 && Game.time - gameState.lastAttackTime > 150) {\n        const potentialTargets = ['W1N1', 'W1N2', 'W1N4', 'W2N1', 'W2N2'];\n        const targetRoom = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];\n        military.launchUltraAttack(targetRoom);\n    }\n    \n    // Status report\n    if (Game.time % 10 === 0) {\n        const modeNames = ['PEACETIME', 'ALERT', 'WAR', 'EMERGENCY', 'TOTAL_WAR'];\n        const enemyRooms = Array.from(gameState.enemyRooms).join(', ') || 'None';\n        const attackersReady = Object.keys(Game.creeps).filter(name => {\n            const creep = Game.creeps[name];\n            return (creep.memory.role === 'attacker' || creep.memory.role === 'kamikaze') && \n                   creep.room.name === gameState.roomName;\n        }).length;\n        \n        console.log(`üèÜ ULTRA AI: ${modeNames[gameState.defenseMode]} | Energy: ${room.energyAvailable}/${room.energyCapacityAvailable} | Creeps: ${Object.keys(Game.creeps).length} | Enemies: ${gameState.enemies.length} | Attackers: ${attackersReady} | Enemy Rooms: ${enemyRooms}`);\n    }\n};"}}