{
  "branch": "default",
  "modules": {
    "main": "// Screeps PvP-focused AI - gpt\n// Strategy: fast economy + early defense (ramparts/tower) + mid-game raiders + scouting + strike rally + emergency mode\n\nconst ROLES = {\n  HARVESTER: 'harvester',\n  UPGRADER: 'upgrader',\n  BUILDER: 'builder',\n  DEFENDER: 'defender',\n  ATTACKER: 'attacker',\n  RANGED: 'ranged',\n  HEALER: 'healer',\n  SCOUT: 'scout',\n};\n\nfunction cleanupMemory() {\n  for (const name in Memory.creeps) {\n    if (!(name in Game.creeps)) delete Memory.creeps[name];\n  }\n}\n\nfunction getSpawn() { return Object.values(Game.spawns)[0]; }\n\nfunction roomStats(room) {\n  const energy = room.energyAvailable;\n  const capacity = room.energyCapacityAvailable;\n  const hostiles = room.find(FIND_HOSTILE_CREEPS);\n  const towers = room.find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_TOWER });\n  return { energy, capacity, hostiles, towers };\n}\n\nfunction ensureRamparts(room) {\n  // Ensure ramparts on spawn and towers for basic defense\n  const spots = [];\n  for (const name in Game.spawns) spots.push(Game.spawns[name].pos);\n  const towers = room.find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_TOWER });\n  for (const t of towers) spots.push(t.pos);\n  for (const pos of spots) {\n    const hasRampart = pos.lookFor(LOOK_STRUCTURES).some(s => s.structureType === STRUCTURE_RAMPART);\n    const hasSite = pos.lookFor(LOOK_CONSTRUCTION_SITES).some(s => s.structureType === STRUCTURE_RAMPART);\n    if (!hasRampart && !hasSite) room.createConstructionSite(pos, STRUCTURE_RAMPART);\n  }\n}\n\nfunction planExtensions(room) {\n  // Place early extensions around spawn in rings, respecting RCL limits\n  const ctrl = room.controller;\n  if (!ctrl || !ctrl.my) return;\n  const limits = { 0:0,1:0,2:5,3:10,4:20,5:30,6:40,7:50,8:60 };\n  const maxExt = limits[ctrl.level] || 0;\n  const existing = room.find(FIND_MY_STRUCTURES, {filter: s => s.structureType === STRUCTURE_EXTENSION}).length\n    + room.find(FIND_MY_CONSTRUCTION_SITES, {filter: s => s.structureType === STRUCTURE_EXTENSION}).length;\n  if (existing >= maxExt) return;\n  // center = first spawn\n  const spawn = getSpawn();\n  if (!spawn) return;\n  let placed = 0;\n  for (let r = 2; r <= 5 && existing + placed < maxExt; r++) {\n    for (let dx = -r; dx <= r && existing + placed < maxExt; dx++) {\n      for (let dy = -r; dy <= r && existing + placed < maxExt; dy++) {\n        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue; // ring\n        const x = spawn.pos.x + dx;\n        const y = spawn.pos.y + dy;\n        if (x <= 2 || x >= 47 || y <= 2 || y >= 47) continue;\n        const pos = new RoomPosition(x,y,room.name);\n        const terrain = room.getTerrain().get(x,y);\n        if (terrain === TERRAIN_MASK_WALL) continue;\n        const hasStructure = pos.lookFor(LOOK_STRUCTURES).some(s => s.structureType !== STRUCTURE_ROAD);\n        const hasSite = pos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0;\n        if (!hasStructure && !hasSite) {\n          if (room.createConstructionSite(x,y,STRUCTURE_EXTENSION) === OK) placed++;\n        }\n      }\n    }\n  }\n}\n\nfunction planTowers(room) {\n  const ctrl = room.controller;\n  if (!ctrl || !ctrl.my || ctrl.level < 3) return;\n  const existing = room.find(FIND_MY_STRUCTURES, {filter: s => s.structureType === STRUCTURE_TOWER}).length\n    + room.find(FIND_MY_CONSTRUCTION_SITES, {filter: s => s.structureType === STRUCTURE_TOWER}).length;\n  if (existing >= 1) return; // ensure at least 1 tower early\n  const spawn = getSpawn();\n  if (!spawn) return;\n  // Try to place within radius 3 around spawn on non-wall tile\n  for (let r = 1; r <= 3; r++) {\n    for (let dx = -r; dx <= r; dx++) {\n      for (let dy = -r; dy <= r; dy++) {\n        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;\n        const x = spawn.pos.x + dx;\n        const y = spawn.pos.y + dy;\n        if (x <= 2 || x >= 47 || y <= 2 || y >= 47) continue;\n        if (room.getTerrain().get(x,y) === TERRAIN_MASK_WALL) continue;\n        const pos = new RoomPosition(x,y,room.name);\n        const occupied = pos.look().some(l => (l.structure && l.structure.structureType !== STRUCTURE_ROAD) || l.terrain === 'wall' || l.constructionSite);\n        if (!occupied) {\n          if (room.createConstructionSite(x,y,STRUCTURE_TOWER) === OK) return;\n        }\n      }\n    }\n  }\n}\n\nfunction planContainersAndRoads(room) {\n  const spawn = getSpawn();\n  if (!spawn) return;\n  const targets = [...room.find(FIND_SOURCES), room.controller].filter(Boolean);\n  for (const t of targets) {\n    // Container near target\n    const hasContainer = room.find(FIND_STRUCTURES, {filter: s => s.structureType === STRUCTURE_CONTAINER && s.pos.inRangeTo(t,1)}).length\n      || room.find(FIND_CONSTRUCTION_SITES, {filter: s => s.structureType === STRUCTURE_CONTAINER && s.pos.inRangeTo(t,1)}).length;\n    if (!hasContainer) {\n      // pick an adjacent free tile for container\n      for (let dx = -1; dx <= 1; dx++) {\n        for (let dy = -1; dy <= 1; dy++) {\n          if (dx === 0 && dy === 0) continue;\n          const x = t.pos.x + dx, y = t.pos.y + dy;\n          if (x <= 1 || x >= 48 || y <= 1 || y >= 48) continue;\n          if (room.getTerrain().get(x,y) === TERRAIN_MASK_WALL) continue;\n          const pos = new RoomPosition(x,y,room.name);\n          const blocked = pos.look().some(l => (l.structure && l.structure.structureType !== STRUCTURE_ROAD) || l.terrain === 'wall' || l.constructionSite);\n          if (!blocked) { room.createConstructionSite(x,y,STRUCTURE_CONTAINER); dx = 2; dy = 2; break; }\n        }\n      }\n    }\n    // Roads from spawn to target\n    const path = room.findPath(spawn.pos, t.pos, { ignoreCreeps: true, ignoreRoads: false, maxOps: 2000 });\n    for (const step of path) {\n      if (room.getTerrain().get(step.x, step.y) === TERRAIN_MASK_WALL) continue;\n      const pos = new RoomPosition(step.x, step.y, room.name);\n      const hasRoad = pos.lookFor(LOOK_STRUCTURES).some(s => s.structureType === STRUCTURE_ROAD)\n        || pos.lookFor(LOOK_CONSTRUCTION_SITES).some(s => s.structureType === STRUCTURE_ROAD);\n      if (!hasRoad) room.createConstructionSite(step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n}\n\nfunction towerRun(room) {\n  const towers = room.find(FIND_MY_STRUCTURES, { filter: s => s.structureType === STRUCTURE_TOWER });\n  for (const tower of towers) {\n    const hostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (hostile) { tower.attack(hostile); continue; }\n    const injured = tower.pos.findClosestByRange(FIND_MY_CREEPS, { filter: c => c.hits < c.hitsMax });\n    if (injured) { tower.heal(injured); continue; }\n    // Controlled repairs: ramparts/walls to a target hit level depending on energy\n    const energy = tower.store[RESOURCE_ENERGY];\n    const emergency = Memory.emergency ? 15000 : 0;\n    const repairCap = energy > 600 ? 100000 : (energy > 300 ? 50000 : 20000);\n    const target = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n      filter: s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL)\n        && s.hits < Math.min(repairCap - emergency, s.hitsMax)\n    });\n    if (target) tower.repair(target);\n  }\n}\n\nfunction getBody(energy, type) {\n  // Flexible body builder\n  const parts = [];\n  const push = (p, n=1) => { for (let i=0;i<n;i++) parts.push(p); };\n  switch (type) {\n    case ROLES.HARVESTER: {\n      // Prefer 2W2C2M then scale\n      const unit = [WORK, WORK, CARRY, CARRY, MOVE, MOVE];\n      while (BODYPART_COST[WORK]*2 + BODYPART_COST[CARRY]*2 + BODYPART_COST[MOVE]*2 <= energy && parts.length + unit.length <= 50) {\n        parts.push(...unit);\n        energy -= 400;\n      }\n      if (parts.length === 0) return [WORK, CARRY, MOVE];\n      return parts;\n    }\n    case ROLES.UPGRADER: {\n      const unit = [WORK, CARRY, MOVE];\n      while (BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE] <= energy && parts.length + 3 <= 50) {\n        parts.push(...unit); energy -= 200;\n      }\n      return parts.length ? parts : [WORK, CARRY, MOVE];\n    }\n    case ROLES.BUILDER: {\n      const unit = [WORK, CARRY, MOVE];\n      while (BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE] <= energy && parts.length + 3 <= 50) {\n        parts.push(...unit); energy -= 200;\n      }\n      return parts.length ? parts : [WORK, CARRY, MOVE];\n    }\n    case ROLES.DEFENDER: {\n      const unit = [ATTACK, MOVE];\n      while (BODYPART_COST[ATTACK] + BODYPART_COST[MOVE] <= energy && parts.length + 2 <= 50) {\n        parts.push(...unit); energy -= 130;\n      }\n      return parts.length ? parts : [ATTACK, MOVE];\n    }\n    case ROLES.RANGED: {\n      const unit = [RANGED_ATTACK, MOVE];\n      while (BODYPART_COST[RANGED_ATTACK] + BODYPART_COST[MOVE] <= energy && parts.length + 2 <= 50) {\n        parts.push(...unit); energy -= 210;\n      }\n      return parts.length ? parts : [RANGED_ATTACK, MOVE];\n    }\n    case ROLES.ATTACKER: {\n      const unit = [ATTACK, MOVE];\n      while (BODYPART_COST[ATTACK] + BODYPART_COST[MOVE] <= energy && parts.length + 2 <= 50) {\n        parts.push(...unit); energy -= 130;\n      }\n      return parts.length ? parts : [ATTACK, MOVE];\n    }\n    case ROLES.HEALER: {\n      const unit = [HEAL, MOVE];\n      while (BODYPART_COST[HEAL] + BODYPART_COST[MOVE] <= energy && parts.length + 2 <= 50) {\n        parts.push(...unit); energy -= 300;\n      }\n      return parts.length ? parts : [HEAL, MOVE];\n    }\n    case ROLES.SCOUT: {\n      return [MOVE];\n    }\n  }\n  return [MOVE, MOVE];\n}\n\n// Intel and targeting\nfunction updateGlobalIntel(room) {\n  // Track best attack target in visible rooms\n  const hostileTower = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_TOWER })[0];\n  const hostileSpawn = room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_SPAWN })[0];\n  const target = hostileTower || hostileSpawn;\n  if (target) {\n    Memory.attackTarget = { x: target.pos.x, y: target.pos.y, roomName: target.pos.roomName, id: target.id, t: Game.time };\n  } else if (Memory.attackTarget) {\n    const obj = Game.getObjectById(Memory.attackTarget.id);\n    if (obj) {\n      Memory.attackTarget.x = obj.pos.x; Memory.attackTarget.y = obj.pos.y; Memory.attackTarget.roomName = obj.pos.roomName; Memory.attackTarget.t = Game.time;\n    } else if (Memory.attackTarget.t + 1000 < Game.time) {\n      // expire stale target after some time\n      delete Memory.attackTarget;\n    }\n  }\n}\n\nfunction moveToGlobalTarget(creep) {\n  const tgt = Memory.attackTarget;\n  if (!tgt) return false;\n  if (creep.room.name === tgt.roomName) {\n    const pos = new RoomPosition(tgt.x, tgt.y, tgt.roomName);\n    creep.moveTo(pos, { reusePath: 5 });\n    return true;\n  } else {\n    const exitDir = Game.map.findExit(creep.room, tgt.roomName);\n    const exit = creep.pos.findClosestByPath(exitDir);\n    if (exit) creep.moveTo(exit, { reusePath: 10 });\n    return true;\n  }\n}\n\nfunction ensureStrikeInit(room) {\n  const spawn = getSpawn();\n  if (!Memory.strike) Memory.strike = { launch: false };\n  if (!Memory.strike.rally && spawn) {\n    Memory.strike.rally = { x: Math.min(47, spawn.pos.x + 1), y: Math.min(47, spawn.pos.y + 1), roomName: spawn.pos.roomName };\n  }\n}\n\nfunction manageEmergency(room) {\n  const spawn = getSpawn();\n  const threat = spawn ? spawn.pos.findInRange(FIND_HOSTILE_CREEPS, 8).length : 0;\n  Memory.emergency = threat > 0;\n}\n\nfunction manageStrike(room) {\n  if (!Memory.strike || !Memory.strike.rally) return;\n  const r = Memory.strike.rally;\n  const pos = new RoomPosition(r.x, r.y, r.roomName);\n  const near = pos.findInRange(FIND_MY_CREEPS, 3);\n  const cnt = role => near.filter(c => c.memory.role === role).length;\n  const attackers = cnt(ROLES.ATTACKER);\n  const ranged = cnt(ROLES.RANGED);\n  const healers = cnt(ROLES.HEALER);\n\n  // Launch condition: enough forces gathered\n  if (!Memory.strike.launch) {\n    if (attackers >= 2 || (attackers >= 1 && (ranged >= 1 || healers >= 1))) {\n      Memory.strike.launch = true;\n      Memory.strike.launchTick = Game.time;\n    }\n  } else {\n    // Reset if no target for a while\n    if (!Memory.attackTarget && Game.time - (Memory.strike.launchTick || 0) > 600) {\n      Memory.strike.launch = false;\n    }\n  }\n}\n\nfunction shouldRally(creep) {\n  const s = Memory.strike;\n  if (!s || s.launch) return false;\n  if (!s.rally) return false;\n  // If immediate combat nearby, skip rally and fight\n  if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 4).length) return false;\n  const rp = new RoomPosition(s.rally.x, s.rally.y, s.rally.roomName);\n  creep.moveTo(rp, { reusePath: 5 });\n  return true;\n}\n\nconst roleHarvester = {\n  run(creep) {\n    if (!creep.memory.working && creep.store.getFreeCapacity() === 0) creep.memory.working = true;\n    if (creep.memory.working && creep.store[RESOURCE_ENERGY] === 0) creep.memory.working = false;\n\n    if (!creep.memory.working) {\n      const src = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n      if (src) {\n        if (creep.harvest(src) === ERR_NOT_IN_RANGE) creep.moveTo(src, {reusePath: 5, visualizePathStyle: {stroke:'#ffaa00'}});\n      }\n    } else {\n      const targets = creep.room.find(FIND_STRUCTURES, {filter: s =>\n        (s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION || s.structureType === STRUCTURE_TOWER)\n        && s.store && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0});\n      if (targets.length) {\n        const t = creep.pos.findClosestByRange(targets);\n        if (creep.transfer(t, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) creep.moveTo(t, {reusePath: 3});\n      } else {\n        if (creep.room.controller) {\n          if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) creep.moveTo(creep.room.controller);\n        }\n      }\n    }\n  }\n};\n\nconst roleUpgrader = {\n  run(creep) {\n    if (!creep.memory.working && creep.store.getFreeCapacity() === 0) creep.memory.working = true;\n    if (creep.memory.working && creep.store[RESOURCE_ENERGY] === 0) creep.memory.working = false;\n\n    if (!creep.memory.working) {\n      const srcs = creep.room.find(FIND_STRUCTURES, {filter: s => s.structureType === STRUCTURE_CONTAINER && s.store[RESOURCE_ENERGY] > 0});\n      const target = srcs.length ? creep.pos.findClosestByRange(srcs) : creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n      if (target && target.structureType) {\n        if (creep.withdraw(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) creep.moveTo(target);\n      } else if (target) {\n        if (creep.harvest(target) === ERR_NOT_IN_RANGE) creep.moveTo(target);\n      }\n    } else if (creep.room.controller) {\n      if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) creep.moveTo(creep.room.controller, {reusePath: 5});\n    }\n  }\n};\n\nconst roleBuilder = {\n  run(creep) {\n    if (!creep.memory.working && creep.store.getFreeCapacity() === 0) creep.memory.working = true;\n    if (creep.memory.working && creep.store[RESOURCE_ENERGY] === 0) creep.memory.working = false;\n\n    if (!creep.memory.working) {\n      const storeTargets = creep.room.find(FIND_STRUCTURES, {filter: s => (s.structureType === STRUCTURE_CONTAINER || s.structureType === STRUCTURE_STORAGE) && s.store[RESOURCE_ENERGY] > 0});\n      const target = storeTargets.length ? creep.pos.findClosestByRange(storeTargets) : creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n      if (target && target.structureType) {\n        if (creep.withdraw(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) creep.moveTo(target);\n      } else if (target) {\n        if (creep.harvest(target) === ERR_NOT_IN_RANGE) creep.moveTo(target);\n      }\n    } else {\n      const site = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n      if (site) {\n        if (creep.build(site) === ERR_NOT_IN_RANGE) creep.moveTo(site, {reusePath: 3});\n      } else {\n        // Repair ramparts/walls first to reasonable threshold, then any structure\n        const rampWall = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: s => (s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL) && s.hits < 30000});\n        if (rampWall) {\n          if (creep.repair(rampWall) === ERR_NOT_IN_RANGE) creep.moveTo(rampWall);\n        } else {\n          const dmg = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: s => s.hits < s.hitsMax && s.structureType !== STRUCTURE_WALL && s.structureType !== STRUCTURE_RAMPART});\n          if (dmg) {\n            if (creep.repair(dmg) === ERR_NOT_IN_RANGE) creep.moveTo(dmg);\n          } else if (creep.room.controller) {\n            if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) creep.moveTo(creep.room.controller);\n          }\n        }\n      }\n    }\n  }\n};\n\nconst roleDefender = {\n  run(creep) {\n    // Rally before launch unless engaged\n    if (shouldRally(creep)) return;\n\n    const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n    if (hostile) {\n      if (creep.attack(hostile) === ERR_NOT_IN_RANGE) creep.moveTo(hostile, {reusePath: 3});\n      return;\n    }\n    // Offensive: attack high-value hostile structures if visible\n    const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n      filter: s => s.structureType === STRUCTURE_TOWER || s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION\n    });\n    if (structure) {\n      if (creep.attack(structure) === ERR_NOT_IN_RANGE) creep.moveTo(structure, {reusePath: 3});\n      return;\n    }\n    // Move to global target if any\n    if (moveToGlobalTarget(creep)) return;\n    // Idle on rampart near spawn\n    const spawn = getSpawn();\n    if (spawn) creep.moveTo(spawn, {range: 2});\n  }\n};\n\nconst roleRanged = {\n  run(creep) {\n    // Rally before launch unless engaged\n    if (shouldRally(creep)) return;\n\n    const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n    if (hostile) {\n      const range = creep.pos.getRangeTo(hostile);\n      if (range > 3) creep.moveTo(hostile, {reusePath: 2});\n      else if (range < 3) creep.moveTo(creep.pos.findClosestByPath(FIND_MY_STRUCTURES) || creep.room.controller || creep);\n      creep.rangedAttack(hostile);\n      return;\n    }\n    // Offensive vs structures\n    const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n      filter: s => s.structureType === STRUCTURE_TOWER || s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION\n    });\n    if (structure) {\n      if (creep.pos.inRangeTo(structure, 3)) creep.rangedAttack(structure); else creep.moveTo(structure, {reusePath: 2});\n      return;\n    }\n    if (moveToGlobalTarget(creep)) return;\n    const spawn = getSpawn();\n    if (spawn) creep.moveTo(spawn, {range: 3});\n  }\n};\n\nconst roleAttacker = {\n  run(creep) {\n    // Rally before launch unless engaged\n    if (shouldRally(creep)) return;\n\n    const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n    if (hostile) {\n      if (creep.attack(hostile) === ERR_NOT_IN_RANGE) creep.moveTo(hostile, {reusePath: 2});\n      return;\n    }\n    // Target priority: towers > spawns > extensions > any hostile structure\n    const structure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n      filter: s => s.structureType === STRUCTURE_TOWER || s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION\n    }) || creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES);\n    if (structure) {\n      if (creep.attack(structure) === ERR_NOT_IN_RANGE) creep.moveTo(structure, {reusePath: 2});\n      return;\n    }\n    if (moveToGlobalTarget(creep)) return;\n    // fallback idle near spawn\n    const spawn = getSpawn();\n    if (spawn) creep.moveTo(spawn, {range: 2});\n  }\n};\n\nconst roleHealer = {\n  run(creep) {\n    // Rally before launch unless engaged or someone is injured\n    if (!creep.pos.findInRange(FIND_MY_CREEPS, 1).some(c=>c.hits < c.hitsMax) && shouldRally(creep)) return;\n\n    const injured = creep.pos.findClosestByPath(FIND_MY_CREEPS, { filter: c => c.hits < c.hitsMax });\n    if (injured) {\n      if (creep.heal(injured) === ERR_NOT_IN_RANGE) creep.moveTo(injured);\n      return;\n    }\n    const fighters = creep.room.find(FIND_MY_CREEPS, { filter: c => c.memory.role === ROLES.DEFENDER || c.memory.role === ROLES.RANGED || c.memory.role === ROLES.ATTACKER });\n    if (fighters.length) {\n      const f = creep.pos.findClosestByRange(fighters);\n      creep.moveTo(f, {range: 1});\n    } else {\n      const spawn = getSpawn();\n      if (spawn) creep.moveTo(spawn, {range: 2});\n    }\n  }\n};\n\nconst roleScout = {\n  run(creep) {\n    // Circle the room edge to reveal and spot hostiles; then update global intel\n    const room = creep.room;\n    const targetPoints = [new RoomPosition(3,3,room.name), new RoomPosition(46,3,room.name), new RoomPosition(46,46,room.name), new RoomPosition(3,46,room.name)];\n    const idx = (creep.memory.idx || 0) % targetPoints.length;\n    const tp = targetPoints[idx];\n    if (creep.pos.inRangeTo(tp, 1)) creep.memory.idx = (idx + 1) % targetPoints.length; else creep.moveTo(tp, {reusePath: 10});\n    updateGlobalIntel(room);\n  }\n};\n\nfunction desiredCounts(room) {\n  const ctrlLevel = room.controller?.level || 0;\n  const hostileCount = room.find(FIND_HOSTILE_CREEPS).length;\n  const base = { [ROLES.HARVESTER]: 4, [ROLES.UPGRADER]: 2, [ROLES.BUILDER]: 2, [ROLES.DEFENDER]: 0, [ROLES.ATTACKER]: 0, [ROLES.RANGED]: 0, [ROLES.HEALER]: 0, [ROLES.SCOUT]: 1 };\n  if (ctrlLevel >= 2) { base[ROLES.HARVESTER] = 5; base[ROLES.UPGRADER] = 3; base[ROLES.BUILDER] = 2; }\n  if (ctrlLevel >= 3) { base[ROLES.HARVESTER] = 6; base[ROLES.UPGRADER] = 3; base[ROLES.BUILDER] = 3; base[ROLES.DEFENDER] = 1; base[ROLES.ATTACKER] = 2; base[ROLES.RANGED] = 1; }\n  if (ctrlLevel >= 4) { base[ROLES.DEFENDER] = 2; base[ROLES.ATTACKER] = 3; base[ROLES.RANGED] = 1; base[ROLES.HEALER] = 1; }\n  if (hostileCount > 0) { base[ROLES.DEFENDER] += 1; base[ROLES.RANGED] = Math.max(base[ROLES.RANGED], 1); }\n  if (Memory.emergency) { base[ROLES.DEFENDER] = Math.max(base[ROLES.DEFENDER], 3); base[ROLES.RANGED] = Math.max(base[ROLES.RANGED], 1); }\n  return base;\n}\n\nfunction spawnLoop(room) {\n  const spawn = getSpawn();\n  if (!spawn || spawn.spawning) return;\n  const counts = Object.values(Game.creeps).reduce((acc,c)=>{acc[c.memory.role]= (acc[c.memory.role]||0)+1; return acc;},{})\n  const target = desiredCounts(room);\n  // Priority: harvesters -> defenders -> attackers -> builders -> upgraders -> ranged -> healer -> scout\n  const priority = [ROLES.HARVESTER, ROLES.DEFENDER, ROLES.ATTACKER, ROLES.BUILDER, ROLES.UPGRADER, ROLES.RANGED, ROLES.HEALER, ROLES.SCOUT];\n  for (const role of priority) {\n    if ((counts[role]||0) < (target[role]||0)) {\n      const body = getBody(room.energyAvailable, role);\n      const name = `${role}-${Game.time}`;\n      const memory = { role, working: false };\n      const res = spawn.spawnCreep(body, name, { memory });\n      if (res === OK) return; // spawned one\n    }\n  }\n}\n\nfunction runCreeps(room) {\n  for (const name in Game.creeps) {\n    const creep = Game.creeps[name];\n    switch (creep.memory.role) {\n      case ROLES.HARVESTER: roleHarvester.run(creep); break;\n      case ROLES.UPGRADER: roleUpgrader.run(creep); break;\n      case ROLES.BUILDER: roleBuilder.run(creep); break;\n      case ROLES.DEFENDER: roleDefender.run(creep); break;\n      case ROLES.ATTACKER: roleAttacker.run(creep); break;\n      case ROLES.RANGED: roleRanged.run(creep); break;\n      case ROLES.HEALER: roleHealer.run(creep); break;\n      case ROLES.SCOUT: roleScout.run(creep); break;\n      default:\n        creep.memory.role = ROLES.HARVESTER;\n        roleHarvester.run(creep);\n    }\n  }\n}\n\nmodule.exports.loop = function() {\n  cleanupMemory();\n  const myRooms = Object.values(Game.rooms).filter(r => r.controller && r.controller.my);\n  if (myRooms.length === 0) return;\n  for (const room of myRooms) {\n    manageEmergency(room);\n    ensureStrikeInit(room);\n    updateGlobalIntel(room);\n    ensureRamparts(room);\n    planExtensions(room);\n    planTowers(room);\n    planContainersAndRoads(room);\n    towerRun(room);\n    manageStrike(room);\n    spawnLoop(room);\n    runCreeps(room);\n  }\n};\n"
  }
}
