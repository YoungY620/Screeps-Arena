# Voyager: An Open-Ended Embodied Agent with Large Language Models

## 论文信息

**论文标题**: Voyager: An Open-Ended Embodied Agent with Large Language Models  
**arXiv**: [2305.16291](https://arxiv.org/abs/2305.16291)  
**发表时间**: 2023年5月 (v1), 2023年10月 (v2)  
**作者**: Guanzhi Wang, Yuqi Xie, Yunfan Jiang, Ajay Mandlekar, Chaowei Xiao, Yuke Zhu, Linxi "Jim" Fan, Anima Anandkumar  
**机构**: NVIDIA, Caltech, UT Austin, Stanford, ASU  
**代码**: https://github.com/MineDojo/Voyager  
**官网**: https://voyager.minedojo.org/

---

## 一、研究背景与动机

### 1.1 核心问题

构建一个能在开放世界中**持续探索、学习、积累技能**的通用具身智能体 (Embodied Agent) 是 AI 领域的重大挑战。

传统方法的局限：

| 方法 | 局限性 |
|------|--------|
| **强化学习 (RL)** | 难以系统性探索、可解释性差、泛化能力弱 |
| **模仿学习** | 需要大量人类示范、难以扩展 |
| **现有 LLM Agent** | 不是终身学习者，无法累积和迁移知识 |

### 1.2 为什么选择 Minecraft？

Minecraft 作为研究环境的独特优势：

```
┌─────────────────────────────────────────────────────────────────┐
│              Minecraft 作为 AI 研究平台的特点                    │
│                                                                 │
│   ✓ 无预定义目标: 没有固定的结局或故事线                        │
│   ✓ 无限可能性: 开放世界，可自由探索和创造                      │
│   ✓ 层次化技能树: 木制工具 → 石制 → 铁制 → 钻石级               │
│   ✓ 组合性任务: 复杂任务由简单技能组合而成                      │
│   ✓ 真实世界类比: 反映人类在开放环境中的学习方式                │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 理想的终身学习智能体应具备什么能力？

论文定义了有效终身学习智能体的三个核心能力：

| 能力 | 描述 | Minecraft 示例 |
|------|------|---------------|
| **情境感知的任务提议** | 根据当前技能水平和世界状态提出合适任务 | 如果在沙漠，先学收集沙子和仙人掌，而非寻找木材 |
| **基于反馈的技能精炼** | 从环境反馈中改进技能，并将掌握的技能存入记忆 | 打僵尸和打蜘蛛的技能可以复用 |
| **自驱动的持续探索** | 主动寻求新任务，不断拓展能力边界 | 不满足于基础生存，追求更高级目标 |

---

## 二、Voyager 核心架构

Voyager 由**三个关键模块**组成：

```
┌────────────────────────────────────────────────────────────────────────┐
│                        Voyager 架构总览                                │
│                                                                        │
│   ┌─────────────────────────────────────────────────────────────────┐ │
│   │                       GPT-4 (黑盒 LLM)                          │ │
│   │                    无需微调，仅通过 Prompt 交互                  │ │
│   └───────────────────────────┬─────────────────────────────────────┘ │
│                               │                                        │
│           ┌───────────────────┼───────────────────┐                   │
│           ▼                   ▼                   ▼                   │
│   ┌───────────────┐   ┌───────────────┐   ┌───────────────┐          │
│   │   Automatic    │   │    Skill      │   │   Iterative   │          │
│   │   Curriculum   │   │    Library    │   │   Prompting   │          │
│   │   自动课程     │   │    技能库     │   │   迭代提示    │          │
│   └───────┬───────┘   └───────┬───────┘   └───────┬───────┘          │
│           │                   │                   │                   │
│           │                   │                   │                   │
│           └───────────────────┴───────────────────┘                   │
│                               │                                        │
│                               ▼                                        │
│                   ┌─────────────────────┐                             │
│                   │    Minecraft 环境    │                             │
│                   │   (执行生成的代码)   │                             │
│                   └─────────────────────┘                             │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.1 模块一：自动课程 (Automatic Curriculum)

**目标**: 最大化探索，让智能体持续发现新事物

**核心机制**:

```
┌─────────────────────────────────────────────────────────────────┐
│                     自动课程生成机制                             │
│                                                                 │
│   输入到 GPT-4:                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ • 探索进度: 已获得的物品、已解锁的成就                   │  │
│   │ • 当前状态: 生命值、饥饿值、位置、时间(白天/黑夜)        │  │
│   │ • 周围环境: 附近的方块、生物、资源                       │  │
│   │ • 总体目标: "尽可能发现更多不同的东西"                   │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              │                                  │
│                              ▼                                  │
│   GPT-4 生成:                                                   │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ 下一个要完成的任务                                       │  │
│   │ 例如: "制作一把石斧" 或 "找到并开采铁矿"                 │  │
│   └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

**设计亮点**:
- **情境敏感**: 根据当前处境动态调整，而非按固定顺序
- **新颖性搜索**: 类似于进化算法中的 novelty search，追求发现新事物
- **无需人工设计**: 课程由 LLM 自动生成，无需预定义任务序列

### 2.2 模块二：技能库 (Skill Library)

**目标**: 存储和检索可复用的复杂行为，避免灾难性遗忘

**核心机制**:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          技能库 (Skill Library)                         │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                       技能存储 (Add Skill)                      │  │
│   │                                                                 │  │
│   │   成功执行的代码                                                │  │
│   │        │                                                        │  │
│   │        ▼                                                        │  │
│   │   生成描述 ──► 计算嵌入向量 ──► 存入向量数据库                  │  │
│   │        │                                                        │  │
│   │        ▼                                                        │  │
│   │   ┌────────────────────────────────────────────────────────┐   │  │
│   │   │ 技能条目:                                               │   │  │
│   │   │ • 描述: "使用熔炉冶炼铁矿石获得铁锭"                    │   │  │
│   │   │ • 代码: async function smeltIronOre(bot) { ... }        │   │  │
│   │   │ • 嵌入: [0.23, -0.41, 0.87, ...]                        │   │  │
│   │   └────────────────────────────────────────────────────────┘   │  │
│   └─────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                      技能检索 (Retrieve Skill)                  │  │
│   │                                                                 │  │
│   │   新任务 (来自自动课程)                                         │  │
│   │        │                                                        │  │
│   │        ▼                                                        │  │
│   │   计算任务嵌入 ──► 向量相似度搜索 ──► 返回 Top-5 相关技能       │  │
│   │        │                                                        │  │
│   │        ▼                                                        │  │
│   │   ┌────────────────────────────────────────────────────────┐   │  │
│   │   │ 检索结果 (注入 Prompt):                                 │   │  │
│   │   │ • craftWoodenPickaxe() - 制作木镐                       │   │  │
│   │   │ • mineStone() - 开采石头                                │   │  │
│   │   │ • craftFurnace() - 制作熔炉                             │   │  │
│   │   │ ...                                                     │   │  │
│   │   └────────────────────────────────────────────────────────┘   │  │
│   └─────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

**技能表示形式**: 可执行的 JavaScript 代码

**为什么选择代码作为技能表示？**

| 特性 | 说明 | 优势 |
|------|------|------|
| **时间延展性** | 技能可以包含多个步骤和等待 | 适合长时程任务 |
| **可解释性** | 代码逻辑清晰可读 | 便于调试和理解 |
| **组合性** | 技能可以互相调用 | 能力快速叠加 |

**组合性示例**:

```javascript
// 低级技能
async function mineWood(bot) { ... }
async function craftPlanks(bot) { ... }
async function craftSticks(bot) { ... }

// 高级技能 (组合低级技能)
async function craftWoodenPickaxe(bot) {
    await mineWood(bot);
    await craftPlanks(bot);
    await craftSticks(bot);
    // 合成木镐...
}
```

### 2.3 模块三：迭代提示机制 (Iterative Prompting)

**目标**: 通过多轮反馈迭代改进生成的代码

**核心机制**:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     迭代提示机制 (Iterative Prompting)                  │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                     1. 环境反馈 (Environment Feedback)          │  │
│   │                                                                 │  │
│   │   代码执行后，环境返回:                                         │  │
│   │   • 背包内容变化                                                │  │
│   │   • 生命值/饥饿值变化                                           │  │
│   │   • 当前位置                                                    │  │
│   │   • 任何相关的游戏事件                                          │  │
│   │                                                                 │  │
│   │   示例: GPT-4 意识到 "需要再获取2块木板才能制作木棍"            │  │
│   └─────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                     2. 执行错误 (Execution Error)               │  │
│   │                                                                 │  │
│   │   如果代码执行出错，错误信息反馈给 GPT-4                        │  │
│   │                                                                 │  │
│   │   示例: 尝试制作 "acacia_axe" (不存在)                          │  │
│   │         → GPT-4 意识到应该制作 "wooden_axe"                     │  │
│   └─────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                     3. 自我验证 (Self-Verification)             │  │
│   │                                                                 │  │
│   │   将当前状态和任务目标发送给 GPT-4，让其作为 "评审者":          │  │
│   │   • 判断任务是否成功完成                                        │  │
│   │   • 如果失败，提供改进建议                                      │  │
│   │                                                                 │  │
│   │   GPT-4 作为评审者 (Critic):                                    │  │
│   │   ┌─────────────────────────────────────────────────────────┐  │  │
│   │   │ Q: 任务 "获得一个熔炉" 是否完成?                        │  │  │
│   │   │ 当前状态: 背包中有 [cobblestone x 8]                    │  │  │
│   │   │                                                         │  │  │
│   │   │ A: 任务未完成。建议: 使用工作台将8个圆石合成为熔炉。    │  │  │
│   │   └─────────────────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

**迭代流程图**:

```
┌─────────────────────────────────────────────────────────────────┐
│                       迭代提示流程                               │
│                                                                 │
│   任务 (从自动课程获取)                                         │
│        │                                                        │
│        ▼                                                        │
│   检索相关技能 (从技能库)                                       │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │            GPT-4 生成代码 (Action Code)                 │  │
│   └─────────────────────────┬───────────────────────────────┘  │
│                             │                                   │
│                             ▼                                   │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │            在 Minecraft 中执行代码                      │  │
│   └─────────────────────────┬───────────────────────────────┘  │
│                             │                                   │
│              ┌──────────────┴──────────────┐                   │
│              ▼                              ▼                   │
│        执行成功                         执行失败/未完成         │
│              │                              │                   │
│              ▼                              ▼                   │
│   ┌──────────────────┐          ┌──────────────────────────┐   │
│   │  自我验证通过?   │          │  收集反馈:              │   │
│   │       │          │          │  • 环境状态变化          │   │
│   │       ▼          │          │  • 错误信息              │   │
│   │    ┌──┴──┐       │          │  • 自我验证评价          │   │
│   │   Yes   No       │          └───────────┬──────────────┘   │
│   │    │    │        │                      │                   │
│   │    ▼    └────────┼──────────────────────┘                   │
│   │ 技能存入库       │                      │                   │
│   │    │             │                      ▼                   │
│   │    ▼             │          ┌──────────────────────────┐   │
│   │ 进入下一任务     │          │  GPT-4 根据反馈改进代码  │   │
│   └──────────────────┘          └───────────┬──────────────┘   │
│                                             │                   │
│                                             └───── 循环迭代     │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、关键设计决策

### 3.1 代码作为动作空间 (Code as Action Space)

**为什么不用低级动作?**

| 对比 | 低级动作 (如: 前进、左转、点击) | 代码 (JavaScript 函数) |
|------|--------------------------------|------------------------|
| **时间尺度** | 单步操作 | 可表示长时程复合动作 |
| **可解释性** | 难以理解意图 | 逻辑清晰，便于调试 |
| **可复用性** | 需要重新学习 | 函数可直接调用 |
| **组合性** | 难以组合 | 天然支持函数嵌套 |

### 3.2 黑盒 LLM 交互 (Blackbox LLM)

Voyager **仅通过 Prompt 与 GPT-4 交互**，不需要：
- 模型参数访问
- 梯度计算
- 微调训练

**优势**:
- 可使用最先进的闭源模型 (GPT-4, Claude 等)
- 避免微调导致的泛化能力下降
- 部署简单，成本可控

### 3.3 技能库的永久性

```
┌─────────────────────────────────────────────────────────────────┐
│              技能库解决"灾难性遗忘"问题                          │
│                                                                 │
│   传统 RL:                                                      │
│   学习任务A ──► 学习任务B ──► 遗忘任务A 的技能 (灾难性遗忘)     │
│                                                                 │
│   Voyager:                                                      │
│   学习任务A ──► 技能存入库 ──► 学习任务B ──► 技能存入库         │
│                     │                            │              │
│                     └────────────────────────────┘              │
│                               │                                 │
│                               ▼                                 │
│                    技能库持续增长，知识永不丢失                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 四、实验结果

### 4.1 探索能力对比

在 160 次 Prompt 迭代内发现的独特物品数量：

| 方法 | 独特物品数 | 相对 Voyager |
|------|-----------|-------------|
| **Voyager** | **63** | 1.0x |
| AutoGPT | 19 | 0.30x |
| ReAct | ~10 | ~0.16x |
| Reflexion | ~8 | ~0.13x |

**Voyager 发现的独特物品数量是 SOTA 的 3.3 倍**

### 4.2 技术树掌握速度

Minecraft 技术树: 木制工具 → 石制工具 → 铁制工具 → 钻石工具

| 阶段 | Voyager 迭代次数 | 基线最快 | 加速比 |
|------|-----------------|---------|--------|
| **木制级别** | ~5 | ~76 | **15.3x** |
| **石制级别** | ~15 | ~128 | **8.5x** |
| **铁制级别** | ~50 | ~320 | **6.4x** |
| **钻石级别** | 解锁成功 | 无法解锁 | **∞** |

**Voyager 是唯一成功解锁钻石级别技术树的方法**

### 4.3 地图探索范围

```
┌─────────────────────────────────────────────────────────────────┐
│                    地图探索对比                                  │
│                                                                 │
│   Voyager:                                                      │
│   ┌───────────────────────────────────────────────────────────┐│
│   │                                                           ││
│   │     ████████████████████████████████████████████          ││
│   │     █                                          █          ││
│   │     █          探索轨迹覆盖多种地形             █          ││
│   │     █          沙漠、森林、山地、海洋           █          ││
│   │     █                                          █          ││
│   │     ████████████████████████████████████████████          ││
│   │                                                           ││
│   └───────────────────────────────────────────────────────────┘│
│   移动距离: 2.3x 基线                                           │
│                                                                 │
│   基线方法:                                                     │
│   ┌───────────────────────────────────────────────────────────┐│
│   │                     ███                                   ││
│   │                    █   █                                  ││
│   │                    █   █  被困在局部区域                   ││
│   │                    █   █                                  ││
│   │                     ███                                   ││
│   └───────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 零样本泛化到新任务

在**全新的 Minecraft 世界**中测试未见过的任务：

| 任务 | Voyager | AutoGPT | ReAct | Reflexion |
|------|---------|---------|-------|-----------|
| 获得钻石镐 | **3/3 成功** | 0/3 | 0/3 | 0/3 |
| 建造避难所 | **3/3 成功** | 0/3 | 0/3 | 0/3 |
| 获得附魔金苹果 | **3/3 成功** | 0/3 | 0/3 | 0/3 |

**关键发现**: Voyager 的技能库不仅帮助 Voyager 自身，**还能作为"即插即用"资产提升其他方法的性能**！

### 4.5 消融实验

移除各组件后的性能影响：

| 配置 | 探索物品数 |
|------|-----------|
| **完整 Voyager (GPT-4)** | **63** |
| 无自动课程 | 45 |
| 无技能库 | 37 |
| 无自我验证 | 48 |
| 使用 GPT-3.5 替代 GPT-4 | 23 |

**结论**: 
- 每个组件都不可或缺
- GPT-4 的代码生成能力显著优于 GPT-3.5

---

## 五、Voyager 与其他方法的关系

### 5.1 与 ExpeL 的对比

| 维度 | Voyager | ExpeL |
|------|---------|-------|
| **知识存储形式** | 可执行代码 (技能) | 自然语言洞见 |
| **应用场景** | 具身任务 (Minecraft) | 决策任务 (QA, 网页交互) |
| **学习信号** | 执行成功/失败 + 环境反馈 | 成功/失败轨迹对比 |
| **复用机制** | 代码函数调用 | Prompt 注入 |

### 5.2 与 Focus Agent 的对比

| 维度 | Voyager | Focus Agent |
|------|---------|-------------|
| **关注点** | 跨任务的技能积累 | 单任务内的上下文压缩 |
| **时间尺度** | 长期 (终身学习) | 短期 (单次任务) |
| **存储内容** | 可复用技能 | 压缩后的学习摘要 |

### 5.3 在 Agent 学习体系中的位置

```
┌─────────────────────────────────────────────────────────────────┐
│                     Agent 学习方法谱系                           │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  参数更新: Fine-tuning, RLHF, SFT                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  无参数更新:                                            │  │
│   │                                                         │  │
│   │   ┌───────────────────────────────────────────────────┐│  │
│   │   │ 反思类: Reflexion, Self-Refine                    ││  │
│   │   └───────────────────────────────────────────────────┘│  │
│   │                                                         │  │
│   │   ┌───────────────────────────────────────────────────┐│  │
│   │   │ 经验积累类:                                       ││  │
│   │   │   • ExpeL: 积累自然语言洞见                       ││  │
│   │   │   • Voyager: 积累可执行代码技能 ◄── 本文          ││  │
│   │   └───────────────────────────────────────────────────┘│  │
│   │                                                         │  │
│   │   ┌───────────────────────────────────────────────────┐│  │
│   │   │ 上下文压缩类: Focus Agent, ACON                   ││  │
│   │   └───────────────────────────────────────────────────┘│  │
│   └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 六、核心贡献与启示

### 6.1 核心贡献

1. **首个 LLM 驱动的具身终身学习智能体**: Voyager 证明了 LLM 可以作为终身学习的核心引擎

2. **代码作为技能表示的可行性**: 可执行代码天然具备时间延展性、可解释性和组合性

3. **三模块协同框架**: 自动课程 + 技能库 + 迭代提示的组合效果显著优于单一模块

4. **知识可迁移性**: 学到的技能库可直接用于新世界、新任务，甚至可以增强其他方法

### 6.2 对 Self-Learn Skills 项目的启示

Voyager 与 `experience-crystallizer` 技能的理念高度契合：

| Voyager 概念 | Self-Learn Skills 对应 |
|-------------|----------------------|
| 技能库 (Skill Library) | `skills/learned/` 目录 |
| 技能代码 (JavaScript) | `SKILL.md` + 示例代码 |
| 技能检索 (嵌入向量) | Cursor Rules / 文档检索 |
| 自动课程 | 可扩展为任务发现机制 |
| 迭代提示 | 交互式调试和改进 |

**关键洞见**: 
> "学习不仅仅是参数更新，更是获取**可复用的状态转换**（技能），从而绕过重复的试错探索。"

---

## 七、资源链接

| 资源 | 链接 |
|------|------|
| **arXiv** | https://arxiv.org/abs/2305.16291 |
| **PDF** | `Voyager_2305.16291.pdf` (本目录) |
| **官网** | https://voyager.minedojo.org/ |
| **代码** | https://github.com/MineDojo/Voyager |
| **MineDojo 平台** | https://minedojo.org/ |

---

## 八、引用

```bibtex
@article{wang2023voyager,
  title = {Voyager: An Open-Ended Embodied Agent with Large Language Models},
  author = {Guanzhi Wang and Yuqi Xie and Yunfan Jiang and Ajay Mandlekar 
            and Chaowei Xiao and Yuke Zhu and Linxi Fan and Anima Anandkumar},
  year = {2023},
  journal = {arXiv preprint arXiv:2305.16291}
}
```

